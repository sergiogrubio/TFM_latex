<p><img src="uoc-logo.png" alt="image" /></p>
<p><span><strong>testDEX: Un DEX simple en la xarxa Elrond</strong></span></p>
<p><strong>Sergio González Rubio</strong><br />
Màster universitari de Ciberseguretat i Privadesa<br />
Sistemes de blockchain</p>
<p><strong>Consultor</strong>: Josep Lluís de la Rosa Esteva<br />
<strong>Professor</strong>: Victor Garcia Font</p>
<p><img src="licencia-cc.png" alt="image" /> Aquesta obra està subjecta a una llicència de<br />
Reconeixement-NoComercial-SenseObraDerivada<br />
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/es/">3.0 Espanya de Creative Commons</a></p>
<p><strong>FITXA DEL TREBALL FINAL</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Títol del treball:</strong></th>
<th style="text-align: left;"><em>testDEX: Un DEX simple en la xarxa Elrond</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Nom de l’autor:</strong></td>
<td style="text-align: left;"><em>Sergio González Rubio</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Nom del consultor/a:</strong></td>
<td style="text-align: left;"><em>Josep Lluís de la Rosa Esteva</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Nom del PRA:</strong></td>
<td style="text-align: left;"><em>Victor Garcia Font</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Data de lliurament (mm/aaaa):</strong></td>
<td style="text-align: left;"><em>juny/2022</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Titulació o programa:</strong></td>
<td style="text-align: left;"><em>Màster universitari de Ciberseguretat i Privadesa</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Àrea del treball final:</strong></td>
<td style="text-align: left;"><em>Sistemes de blockchain</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Idioma del treball:</strong></td>
<td style="text-align: left;"><em>Català</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Paraules clau:</strong></td>
<td style="text-align: left;"><em>Elrond, blockchain, EGLD, smart contract, swap</em></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Resum del treball:</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">L’adveniment Bitcoin i posteriorment d’Ethereum varen definir les bases de la tecnologia <em>blockchain</em>. Cal destacar que han suposat una disrupció tecnològica, econòmica i fins i tot política, despertant un interès acadèmic creixent i nous casos d’ús. En aquest context, es presenten reptes per aconseguir una descentralització plena que sigui capaç de substituir els sistemes centralitzats tradicionals de transaccions electròniques i moviment de capitals. Alt consum d’energia, baixa taxa de transaccions, escalabilitat, seguretat o interoperabilitat són alguns dels reptes plantejats per les tecnologies actuals de <em>blockchain</em> que resol Elrond. Aquest treball presenta un exemple d’implementació de <em>swaps</em> entre criptovalors amb l’objectiu de comprovar que la proposta de <em>blockchain</em> pública d’Elrond ha vençut les limitacions actuals de Bitcoin i Ethereum.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Abstract:</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">The advent of Bitcoin and later of Ethereum described the foundations of blockchain technology. It should be noted that they have led to a technological, economical and even political disruption, arousing growing academic interest and new use cases. In this context, we are being challenged to achieve full decentralization that is capable of replacing traditional centralized systems of electronic transactions and movements of capital. High energy consumption, low transaction rates, scalability, security or interoperability are some challenges of current blockchain technologies that Elrond solves. This paper presents an example of the implementation of swaps between tokens in order to verify that Elrond’s public blockchain proposal has overcome the current limitations of Bitcoin and Ethereum.</td>
</tr>
</tbody>
</table>
<h1 id="introducció">Introducció</h1>
<h2 id="sub:context">Context i justificació del treball</h2>
<p>El <em>white paper</em> de <strong>Bitcoin</strong> fou presentat l’any 2008 per una o diverses persones ocultes rere el pseudònim de Satoshi Nakamoto <span class="citation" data-cites="nakamoto2008"></span>. Tot i que existien intents anteriors<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, fou la primera solució “creïble” <span class="citation" data-cites="vuterin2014"></span> que va permetre transferir fons sense la intervenció de terceres parts (cosa que inclou a bancs centrals encarregats d’emetre la moneda). Gràcies a la implementació d’un programari client –lliure i de codi obert– s’estableix una xarxa d’igual a igual (<em>peer-to-peer</em>) on es connecten nodes –no controlats– que verifiquen i emmagatzemen en una base de dades pública la comptabilitat dels moviments entre usuaris de la xarxa. Les operacions s’agrupen en blocs, que s’enllacen i xifren per assegurar que no hi hagi modificacions malicioses posteriors. Els càlculs per realitzar el xifratge tenen cert nivell de dificultat i comporten una despesa energètica considerable, per aquest motiu s’incentiva els nodes “miners” amb una recompensa quan aconsegueixen crear un nou bloc a la cadena. Per això es coneix aquesta tecnologia com a <em>blockchain</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Així mateix, com afirma V. Buterin <span class="citation" data-cites="vuterin2014"></span>, l’altra gran aportació és la manera com aplica el concepte de <em>Proof-of-Work</em> (PoW) perquè els nodes arribin a un consens per validar les transaccions solucionant certs problemes (com, per exemple, el de la doble despesa). Amb PoW es pretén evitar que nodes de la xarxa tinguin comportaments indesitjats. Com ja s’ha remarcat, a Bitcoin els càlculs de xifratge per crear un nou bloc comporten molta feina computacional, però la validació d’un bloc ja creat requereix un esforç molt inferior. Si dos nodes distribueixen simultàniament diferents versions del següent bloc, el que tingui la cadena més llarga serà el que els nodes acceptin com a vàlid i descartaran la resta <span class="citation" data-cites="nakamoto2008"></span>. Finalment, el protocol de Bitcoin també disposa d’un llenguatge de <em>scripting</em>, encara que amb limitacions importants (per exemple, no és Turing complet i no té estat <span class="citation" data-cites="vuterin2014"></span>).</p>
<p>El 2014 V. Buterin va presentar el <em>white paper</em> d’<strong>Ethereum</strong> <span class="citation" data-cites="vuterin2014"></span> (la xarxa es va posar en producció el 30 de juliol de 2015 <span class="citation" data-cites="tual2015"></span>). Igual que passa amb Bitcoin, s’utilitza el concepte PoW com a mecanisme de consens entre nodes, però s’incorpora un llenguatge anomenat “Solidity” (que sí que és Touring complet) per a la creació de “<em>smart contracts</em>” i d’aplicacions descentralitzades (o “DApps”). Els contractes intel·ligents són programes desplegats (o guardats) a la cadena de blocs que s’executen automàticament quan es compleixen certes condicions. A més, una DApp és una aplicació que funciona sense la necessitat de servidors centrals (gràcies a la tecnologia descrita). En el moment en què redacto aquestes línies, la versió d’Ethereum 2.0 “Serenity” encara no està completament desenvolupada. Aquest nou <em>fork</em> ha d’introduir millores com substituir el PoW per <em>Proof-of-Stake</em> (PoS), per reduir el consum d’energia, o com aplicar tècniques de <em>sharding</em> per augmentar l’eficiència (la versió actual de la xarxa no arriba a suportar les 20 transaccions per segon <span class="citation" data-cites="mech2018"></span>).</p>
<p>Amb Bitcoin i Ethereum consolidats, “The Elrond Team” va publicar el 19 de juny de 2019 el <em>white paper</em> d’una nova solució de cadena de blocs pública sota el títol “<em><strong>Elrond</strong>: A Highly Scalable Public Blockchain via Adaptive State Sharding and Secure Proof of Stake</em>”. Entre els reptes que plantejaren <span class="citation" data-cites="elrond2022"></span><span class="citation" data-cites="elrond2019"></span>:</p>
<ul>
<li><p>Descentralització plena.</p></li>
<li><p>Seguretat robusta de les transaccions, prevenint qualsevol vector d’atac conegut.</p></li>
<li><p>Alta escalabilitat, arribant al nivell de rendiment d’algun dels serveis equiparables amb arquitectura centralitzada.</p></li>
<li><p>Eficiència a tots els serveis de xarxa amb el mínim consum energètic i esforç computacional.</p></li>
<li><p>Millora de l’emmagatzematge i la sincronització de dades.</p></li>
<li><p>Interoperabilitat entre cadenes de blocs des del disseny.</p></li>
</ul>
<p>Tot i la data de publicació del <em>white paper</em>, l’equip d’Elrond assegura que el seu <em>mainnet</em> és actiu des de l’any 2018. A més, citen com a aconseguides en la data de redacció del present treball les següents fites <span class="citation" data-cites="elrond2022"></span><span class="citation" data-cites="mincul2021"></span>:</p>
<ul>
<li><p>Primera arquitectura de <em>blockchain</em> en producció amb fragmentació d’estat (<em>state sharding</em>).</p></li>
<li><p>1,5k TPS (escalable a més de 100k TPS<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>), latència de 6s i cost de $0,001 per transacció.</p></li>
<li><p>Maiar App<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (moneder mòbil d’Elrond), Elrond Web Wallet<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> i Maiar DeFi Wallet<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p></li>
<li><p><em>Smart Contracts</em>, <em>Staking &amp; Delegation</em>, <em>Tokens</em>.</p></li>
<li><p>Maiar DEX<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p></li>
<li><p>DeFi 2.0: Préstecs, sintètics.</p></li>
<li><p>Validat mitjançant múltiples auditories per part de l’empresa Trail of Bits<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> i d’altres.</p></li>
</ul>
<p>Referent al darrer punt, he cercat informació sobre quines auditories s’han fet i la informació que he trobat és escassa (pareix que per qüestions de seguretat han estat majoritàriament auditories internes <span class="citation" data-cites="mincub2019"></span>). Sí que apareix un acord de col·laboració per emprar les eines de l’empresa Runtime Verification<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> i que s’han oferit recompenses a <em>white-hat hackers</em> <span class="citation" data-cites="bounties01"></span><span class="citation" data-cites="mincub2021"></span>.</p>
<p>Tot i que hi ha altres projectes prometedors com Solana, Avalanche, Tron o Tezos <span class="citation" data-cites="baro2021"></span>, en la meva opinió, l’evolució d’Elrond des de l’aparició del seu <em>white paper</em> dona peu a parar el nostre interès acadèmic en aquest projecte i no en els altres. És per aquest motiu que es proposa desenvolupar un <strong>DEX</strong> molt simple que permeti fer intercanvis entre diferents criptomonedes emprant el protocol <strong><em>automated market makers</em></strong> (AMM) <span class="citation" data-cites="cryptopedia2021"></span> amb la intenció de <strong>posar a prova la xarxa d’Elrond</strong>.</p>
<h2 id="sub:objectius">Objetius del treball</h2>
<p>A nivell molt genèric, els quatre grans objectius que pretenc assolir són:</p>
<ul>
<li><p>L’anàlisi i estudi de la tecnologia de <em>blockchain</em> d’Elrond des d’un punt de vista acadèmic.</p></li>
<li><p>La definició d’una proposta d’arquitectura per desenvolupar DApps en la xarxa d’Elrond.</p></li>
<li><p>El desenvolupament d’un exemple pràctic usant l’arquitectura anterior.</p></li>
<li><p>La definició de proves per comprovar característiques de la xarxa d’Elrond.</p></li>
</ul>
<p>Vull destacar en aquest apartat que no he trobat cap altre treball acadèmic sobre la xarxa d’Elrond en llengua catalana. S’ha de destacar que el contingut de la secció <a href="#sec:revelrond" data-reference-type="ref" data-reference="sec:revelrond">2</a> és una tasca de selecció, síntesi i traducció de les fonts citades en les respectives subseccions (bàsicament, <span class="citation" data-cites="elrond2022"></span> i <span class="citation" data-cites="elrond2019"></span>). Òbviament, l’autor no va participar en la creació de la xarxa d’Elrond i, per tant, l’autoria del conceptes que s’exposen és de The Elrond Team.</p>
<h2 id="enfocament-i-mètode-seguit">Enfocament i mètode seguit</h2>
<p>Després de revisar ràpidament l’estat de l’art de les tecnologies <em>blockchain</em>, ha estat una aposta personal fer servir Elrond. És un projecte novedós i sé que, per aquest motiu, disposaré de menys bibliografia que amb Bitcoin o Ethereum. Aquest darrer fet espero que, més que ser una cosa negativa, em permeti fins i tot trobar nous objectius a mesura que vagi investigant. Així mateix, una bona planificació del projecte és ben necessària, on vull destacar que la fase d’investigació es realitzarà de forma paral·lela a la resta.</p>
<p>Les <strong>fases</strong> que es desenvoluparan són les següents:</p>
<ul>
<li><p><strong>Plantejament del problema</strong>: Es duu a terme una entrevista amb Josep Lluís de la Rosa Esteva i es pacta desenvolupar un <strong>DEX</strong> emprant el protocol AMM amb el propòsit de provar i comprovar algunes de les característiques de la tecnologia d’Elrond. Com s’ha comentat, previ a l’entrevista, va haver-hi una feina d’investigació ràpida sobre l’estat de l’art en els sistemes <em>blockchain</em>.</p></li>
<li><p><strong>Pla de treball</strong>: Es definiran els recursos necessaris per fer el projecte, les tasques a fer i la seva temporalització.</p></li>
<li><p><strong>Revisió de la tecnologia d’Elrond</strong>: Es descriurà a tall de resum la tecnologia i s’enumeraran els recursos que hi ha disponibles per desenvolupar en aquesta xarxa.</p></li>
<li><p><strong>testDEX</strong>:</p>
<ul>
<li><p><strong>Anàlisi</strong>: Definició dels requisits i dels models relacionats amb aquests.</p></li>
<li><p><strong>Disseny</strong>: Realització dels models que defineixen el disseny del sistema i l’arquitectura.</p></li>
<li><p><strong>Implementació</strong>: Escriptura del codi font.</p></li>
<li><p><strong>Posada en producció</strong>: Desplegament en producció del projecte.</p></li>
<li><p><strong>Proves</strong>: La fase de proves es durà a terme de forma paral·lela a la implementació i a la de posada en producció. S’han de definir uns criteris de qualitat mínims abans de posar l’aplicatiu en producció (on es continuarà realitzant proves).</p></li>
</ul></li>
<li><p><strong>Redacció de la memòria</strong>: Es farà de forma paral·lela mentre es duen a terme les fases anteriors.</p></li>
<li><p><strong>Creació del vídeo de la presentació final</strong>: Necessari per defensar el treball.</p></li>
<li><p><strong>Investigació i formació</strong>: Pel plantejament inicial del treball, es durà a terme a la vegada que es realitzen la resta de fases.</p></li>
</ul>
<h2 id="planificació-del-treball">Planificació del treball</h2>
<p>Els recursos necessaris per desenvolupar el projecte són mínims: Un ordinador personal amb el seu sistema operatiu i un editor de codi (<em>Visual Studio Code</em><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>). Per altra banda, les tasques a realitzar han estat enumerades en el punt anterior i seran descrites en el seu apartat corresponent. Gràficament en un diagrama de Gantt queden de la següent forma:</p>
<figure>
<img src="gantt.png" style="width:100.0%" alt="" /><figcaption>Diagrama de Gantt del projecte (creat amb GNOME Planner 0.14.6).</figcaption>
</figure>
<p>La següent figura presenta la temporalització de les fases del projecte, s’ha de considerar que un dia de feina correspon a una jornada de quatre hores:</p>
<figure>
<img src="gantttemp.png" style="width:85.0%" alt="" /><figcaption>Temporalització del projecte.</figcaption>
</figure>
<h2 id="breu-sumari-de-productes-obtinguts">Breu sumari de productes obtinguts</h2>
<p>El present treball bàsicament aporta:</p>
<ul>
<li><p>Un <strong>revisió teòrica de la tecnologia</strong> d’Elrond.</p></li>
<li><p>Un <strong>exemple pràctic d’arquitectura</strong> per a aplicacions descentralitzades emprant aquesta tecnologia amb testDEX.</p></li>
<li><p>Un <strong><em>script</em> en Python per testejar el rendiment</strong> de la xarxa.</p></li>
</ul>
<h2 id="breu-descripció-dels-altres-capítols-de-la-memòria">Breu descripció dels altres capítols de la memòria</h2>
<p>En la secció <a href="#sec:revelrond" data-reference-type="ref" data-reference="sec:revelrond">2</a> “Revisió de la tecnologia d’Elrond” es descriuen els conceptes generals d’Elrond, el funcionament bàsic de la seva tecnologia i els productes de l’empresa disponibles. La <a href="#sec:testdex" data-reference-type="ref" data-reference="sec:testdex">3</a> “testDEX” presenta les fases del desenvolupament de l’aplicació de mostra que aplica els conceptes teòrics exposats. En la secció <a href="#sec:con" data-reference-type="ref" data-reference="sec:con">4</a> “Conclusions” es revisa de forma crítica el resultat del present treball. La <a href="#sec:glo" data-reference-type="ref" data-reference="sec:glo">5</a> és un compendi d’acrònims i termes destacables d’aquesta memòria. El <a href="#sec:bib" data-reference-type="ref" data-reference="sec:bib">6</a> enumera la bibliografia emprada. Finalment, en el <a href="#sec:ann" data-reference-type="ref" data-reference="sec:ann">7</a> “Annexos” apareix un petit manual d’usuari de la DApp “testDEX”.</p>
<h1 id="sec:revelrond">Revisió de la tecnologia d’Elrond</h1>
<h2 id="visió-general-de-larquitectura">Visió general de l’arquitectura</h2>
<p>Elrond és una cadena de blocs<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> pública i d’alt rendiment. Altres punts a destacar són <span class="citation" data-cites="elrond2022"></span><span class="citation" data-cites="elrond2022-2"></span>:</p>
<ol>
<li><p><strong>Entitats (usuaris i nodes)</strong>: Els usuaris despleguen transaccions a la xarxa, en forma de transferència de valor o executant un <em>smart contract</em>. Per altra banda, els nodes són dispositius en la xarxa que executen el programari d’Elrond i processen les transaccions.</p></li>
<li><p><strong><em>Validadors</em></strong>: Nodes de la xarxa Elrond amb almenys 2500 EGLD en <em>staking</em> (o bloquejats<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>) que processen les transaccions i asseguren la xarxa per la seva participació en el mecanisme de consens per validar els blocs (seran recompensats amb les tarifes –<em>fees</em>– de les transaccions).</p></li>
<li><p><strong><em>Shards<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></em></strong>: Particions de la xarxa d’Elrond que permeten escalar-la. La feina de cada <em>shard</em> és gestionar una part de l’estat i processar paral·lelament la corresponent part de la transacció.</p></li>
<li><p><strong><em>Adaptive State Sharding</em></strong>: Divisió i unió dinàmica de <em>shards</em> segons el nombre de validadors disponible i càrrega de la xarxa. S’aplica a tots els nivells (transacció, dades i xarxa) de forma adaptativa.</p></li>
<li><p><strong><em>Secure Proof of Stake</em></strong>: Els blocs són validats per consens entre els validadors del grup de consens (valgui la redundància), que és completat en dues passes de comunicació emprant una modificació de les signatures múltiples de Boneh-Lynn-Shacham (BLS) <span class="citation" data-cites="Boneh2004"></span>. El grup de consens és seleccionat aleatòriament i només és possible conèixer la seva composició amb una ronda d’antelació.</p></li>
<li><p><strong>Alta resiliència</strong>: Capacitat de recuperar-se d’atacs maliciosos pel canvi de nodes entre els <em>shards</em> (en cada “època” un terç dels nodes seran reubicats per prevenir connivències entre els mateixos).</p></li>
<li><p><strong>Font d’aleatorietat segura</strong>: Utilitzant la signatura BLS, cosa que la fa no esbiaixada i impredictible.</p></li>
<li><p><strong>Elrond WASM VM</strong>: Màquina virtual específica que permet executar contractes intel·ligents escrits en qualsevol llenguatge de programació que es permeti compilar amb <em>WebAssembly</em><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>.</p></li>
<li><p><strong>Contractes intel·ligents</strong>: Que s’executaran emprant l’<em>Adaptative State Sharding</em>. Elrond recomana que siguin escrits en Rust però, com s’ha dit en el punt anterior, es poden utilitzar altres llenguatges. Una característica única, comparant per exemple amb Ethereum, és que es poden modificar els <em>smart contracts</em> després de ser desplegats <span class="citation" data-cites="cwirko01"></span> (per exemple per corregir errors).</p></li>
<li><p><strong>Execució ràpida de transaccions <em>cross-shard</em></strong>: Gestionada de forma nadiua a nivell de protocol fent servir un algorisme d’expedició (<em>dispatching</em>) i un algorisme d’encaminament.</p></li>
<li><p><strong><em>Metachain</em></strong>: Cadena de blocs que s’executa en un <em>shard</em> especial. El seu rol principal no és processar transaccions sinó que és notificar i autenticar les capçaleres dels blocs processats.</p></li>
<li><p><strong>Elrond Gold (EGLD)</strong>: Criptovalor (<em>token</em>) nadiu de la xarxa Elrond que serveix de mitjà de pagament per a les transaccions. Ajuda en el desplegament de DApps, en l’execució de contractes intel·ligents i també s’empra com a mecanisme de pagament de recompenses per als validadors.</p></li>
</ol>
<h2 id="sub:entitat">Entitats</h2>
<p>Bàsicament, en la xarxa Elrond hi ha dos tipus d’entitats: usuaris i nodes <span class="citation" data-cites="elrond2022"></span>. Un <strong>usuari</strong> és qualsevol ens que gestioni un dels <strong>comptes</strong> –o més– de la xarxa Elrond. Un parell de <strong>claus criptogràfiques</strong> (una pública i una privada) li permetran enviar <strong>transaccions signades</strong> fent servir la xarxa. Els comptes tenen associat una quantitat d’EGLD que es coneix com a <strong>balanç</strong> i a més tenen un espai d’emmagatzematge per a valors arbitraris (com per exemple informació sobre <strong><em>tokens</em> creats pels usuaris</strong>). Els comptes s’identifiquen de forma unívoca per una <strong>adreça</strong> que coincideix amb la clau pública de l’usuari (32 bytes fent servir la representació Bech32). Normalment, els usuaris gestionen els seus parells de claus emprant unes aplicacions informàtiques que s’anomenen <strong>carteres</strong> (o <em>wallets</em>)<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>.</p>
<p>Per altra banda, els <strong>nodes</strong> són dispositius connectats a la xarxa d’Elrond que realitzen les operacions sol·licitades pels seus usuaris. Els nodes poden ser passius (<em>observers</em>) o actius (<em>validators</em> i <em>fishermen</em>). Els validadors s’encarreguen del consens, d’afegir blocs i mantenir l’estat, essent premiats per la seva contribució. Els <strong>validadors</strong> són identificats de forma única per una clau pública BLS de 96 bytes. Per garantir el correcte funcionament dels nodes, els validadors han de tenir en <em>staking</em> com a mínim 2500 EGLD. Sense bloquejar aquesta quantitat d’EGLD, els nodes poden fer d’<strong>observadors</strong> (però no rebran cap recompensa). Aquests darrers són membres passius de la xarxa que poden actuar com a interfície de lectura i retransmissió. Poden ser complets (<em>full)</em>, mantenint tota la història de la cadena de blocs, o lleugers (<em>light</em>), mantenint només 2 èpoques de l’historial de la cadena de blocs. Finalment, trobem els <strong>pescadors</strong> (<em>fishermen</em>). La seva tasca és verificar la validesa dels blocs després d’haver estat proposats, detectant així actors maliciosos <span class="citation" data-cites="elrond2022-2"></span>. Rebran també una recompensa i aquest rol pot ser exercit per observadors o validadors que no formin part de la ronda de consens en curs.<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<h2 id="cronologia">Cronologia</h2>
<p>En la xarxa d’Elrond s’organitza el temps en <strong>èpoques</strong> (<em>epochs</em>) que es subdivideixen en <strong>rondes</strong> (<em>rounds</em>) i <span class="citation" data-cites="elrond2022"></span>. La primera ronda de la primera època (<em>genesis round</em>) és especial i serveix per inicialitzar la xarxa.</p>
<p>Una <strong>època</strong> és una seqüència de rondes consecutives en què la configuració de la xarxa no canvia. El nombre de rondes en una època es calcula perquè aquesta darrera duri 24 hores (això està definit en la configuració actual i és modificable). Quan hi ha un canvi d’època s’aprofita per adaptar la topologia de la xarxa segons el nombre de validadors disponibles i càrrega de treball. En aquest precís moment també s’aprofita per acomplir amb altres tasques per tancar l’època anterior (com calcular les recompenses per als validadors).</p>
<p>Com es pot intuir, les <strong>rondes</strong> tindran una durada fixa que (actualment és configurada en 5 segons). Per l’arquitectura en <em>shards</em> de la xarxa, en cada ronda només es podrà afegir un bloc a la cadena de blocs del <em>shard</em>. Òbviament, si no s’arriba a consens o quan el líder del grup de consens designat és fora de línia i no pot proposar un bloc, pot haver-hi rondes en què no s’afegeixi cap bloc a la <em>blockchain</em>.</p>
<p>S’ha de remarcar que els sistemes que implementen PoS solen dividir el temps de forma similar <span class="citation" data-cites="elrond2019"></span>.</p>
<h2 id="secure-proof-of-stake"><em>Secure Proof of Stake</em></h2>
<p>El funcionament <em>Secure Proof of Stake</em> (SPoS) d’Elrond es pot desgranar en les següents passes <span class="citation" data-cites="elrond2022"></span><span class="citation" data-cites="elrond2019"></span>:</p>
<ol>
<li><p>La font d’aleatorietat per seleccionar els validadors per al consens es calcula a partir del bloc anterior, que és signat pel líder de consens –també conegut com a proposador de blocs o <em>block proposer</em>– de la ronda que acaba. Això implica que aquesta font d’aleatorietat no podrà ser coneguda amb més d’una ronda d’antelació.</p></li>
<li><p>Se selecciona el grup de consens, compost per validadors i un únic <em>block proposer</em>. Una vegada coneguda la font d’aleatorietat, el procediment de tria del grup és determinista (triga menys de 100 ms<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>). S’ha de considerar que per triar els nodes es té en compte la quantitat d’EGLD en <em>staking</em> i una qualificació individual –revisada al final de cada època– que es basa en el comportament passat. Per exemple, es davallarà la seva puntuació si no proposa el bloc perquè és fora de línia, es detecta una activitat maliciosa, etc. Aquesta “meritocràcia” anima els propietaris dels nodes a tenir-los en bon funcionament.</p></li>
<li><p>El líder de consens (o validació) produeix el bloc per a la nova ronda. Si, pel motiu que sigui, no s’ha creat un bloc en una finestra de temps s’utilitzarà la font d’aleatorietat de l’últim bloc per seleccionar un nou grup de consens.</p></li>
<li><p>El líder de consens<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> envia el bloc que acaba de proposar als validadors.</p></li>
<li><p>Aquests darrers components del grup validen i també signen el bloc rebut, basant-se en una modificació de <em>Practical Byzantine Fault Tolerance</em> (pBFT).</p></li>
<li><p>Els validadors trameten les signatures al <em>block proposer</em>.</p></li>
<li><p>El proposador agrega les signatures i distribueix el bloc.</p></li>
<li><p>El <em>hash</em> del bloc, la signatura, les proves d’inclusió i el nombre de <em>shard</em> són enviats a la <em>Metachain</em>.</p></li>
</ol>
<p>Aquestes passes es poden veure resumides en la Fig. <a href="#fig:SPoS" data-reference-type="ref" data-reference="fig:SPoS">2</a>.</p>
<figure>
<img src="SPoS01.png" id="fig:SPoS" alt="" /><figcaption>Estructura d’un bloc en la xarxa Elrond. (Font: Imatge dins l’apartat corresponent a SPoS a <span class="citation" data-cites="elrond2022"></span>).</figcaption>
</figure>
<figure>
<img src="SPoS02.png" id="fig:SPoS" alt="" /><figcaption>Estructura d’un bloc en la xarxa Elrond. (Font: Imatge dins l’apartat corresponent a SPoS a <span class="citation" data-cites="elrond2022"></span>).</figcaption>
</figure>
<h2 id="adaptive-state-sharding"><em>Adaptive State Sharding</em></h2>
<p>El <em>sharding</em> va sorgir originàriament en el camp de les bases de dades com un mètode per distribuir les dades entre múltiples màquines amb l’objectiu de suportar alt rendiment amb grans volums d’informació <span class="citation" data-cites="mongodb2021"></span>. Elrond empra aquesta tècnica d’escalat horitzontal per particionar tant la xarxa com l’estat i processament de les transaccions amb la finalitat que diferents nodes desenvolupin la seva tasca en paral·lel (amb el consegüent augment de l’eficiència). S’ha de destacar també que s’empren els tres tipus principals de <em>sharding</em> <span class="citation" data-cites="elrond2022"></span>:</p>
<ul>
<li><p><strong><em>Network sharding</em></strong><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>: Gestiona com els nodes es distribueixen i agrupen entre els diferents <em>shards</em>. S’ha de tenir en compte que les comunicacions dins del <em>shard</em> són més ràpides que fer una propagació (<em>broadcast</em>) dels missatges a tota la xarxa. Un punt molt important a destacar és que si un atacant arriba a controlar un <em>shard</em> enter suposaria un greu problema de seguretat.</p></li>
<li><p><strong><em>Transaction sharding</em></strong>: S’ocupa la forma en què les transaccions s’assignen als <em>shards</em> encarregats del seu processament. Les transaccions són assignades a un <em>shard</em> de forma determinista emprant les adreces de les transaccions.</p></li>
<li><p><strong><em>State sharding</em></strong>: Cada <em>shard</em> només manté una part de l’estat. Els dos mètodes anteriors, si no es combinessin amb aquest, haurien d’emmagatzemar una còpia entera de tot l’estat. Així, si els comptes implicats en una transacció resideixen en <em>shards</em> diferents, l’execució de la transacció implicaria l’intercanvi de missatges entre nodes per modificar els respectius estats. Com ja s’ha dit, per augmentar la tolerància a atacs maliciosos, quan acaba una època es redistribueixen entre els diferents <em>shards</em> un subconjunt dels nodes.</p></li>
</ul>
<p>Com a resultat d’aquesta fusió s’aconsegueix <span class="citation" data-cites="elrond2022"></span>:</p>
<ul>
<li><p><strong>Escalabilitat sense afectar a la disponibilitat</strong>: En la Fig. <a href="#fig:sharding01a" data-reference-type="ref" data-reference="fig:sharding01a">3</a> podem observar la xarxa amb només un <em>shard</em>. Les figures <a href="#fig:sharding01b" data-reference-type="ref" data-reference="fig:sharding01b">4</a> i <a href="#fig:sharding01c" data-reference-type="ref" data-reference="fig:sharding01c">5</a> mostren una arquitectura amb dos i tres <em>shards</em><a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>. Sense entrar en detall, es pot veure que augmentant o disminuint el nombre de <em>shards</em> –gràcies a la forma en què s’assignen les adreces al seu fragment– s’evita temps d’inactivitat per qüestions de configuració.</p></li>
<li><p><strong>Expedició (<em>dispatching</em>) ràpida i traçabilitat</strong>: La Fig. <a href="#fig:sharding01c" data-reference-type="ref" data-reference="fig:sharding01c">5</a> mostra com es calcula el <em>shard</em> de destí de forma determinista (les adreces de color blau aniran al 0, les verdes a l’1 i les grogues al 2).</p></li>
<li><p><strong>Eficiènia i adaptabilitat</strong>: El sistema permet processar transaccions en paral·lel i adaptar-se a la càrrega de treball i/o estat de la xarxa. Però s’ha de destacar que la distribució dels <em>shards</em> hauria de ser tan equilibrada com fos possible. Si ens fixem en la Fig. <a href="#fig:sharding01c" data-reference-type="ref" data-reference="fig:sharding01c">5</a> veiem que no és equilibrada (ja que el nombre de <em>shards</em> no és una potència de 2).</p></li>
</ul>
<figure>
<img src="sharding01.png" id="fig:sharding01a" alt="" /><figcaption>1 <em>shard</em></figcaption>
</figure>
<figure>
<img src="sharding02.png" id="fig:sharding01b" alt="" /><figcaption>2 <em>shards</em></figcaption>
</figure>
<figure>
<img src="sharding03.png" id="fig:sharding01c" alt="" /><figcaption>3 <em>shards</em></figcaption>
</figure>
<p>Una altra cosa a destacar és que els nodes guarden una <strong>còpia de l’estat dels seus germans (redundància)</strong> per aportar <strong>tolerància a fallades</strong> (Fig. <a href="#fig:shardred" data-reference-type="ref" data-reference="fig:shardred">6</a>).</p>
<p>Finalment, s’ha de remarcar el fet que els <strong>nodes es barregin entre <em>shards</em> al final de cada època</strong> per evitar la connivència entre nodes maliciosos. Això no es fa amb tots els nodes sinó que només es redistribuirà –de forma determinista i uniforme– un nombre controlat de validadors (aquesta tasca la realitza la <em>metachain</em> emprant una font d’aleatorietat procedent del bloc anterior de la metacadena). Es fa així, i no reorganitzant tots els nodes, per maximitzar la seguretat amb la mínima introducció de latències en el sistema. Els nodes triats es col·locaran als seus nous <em>shards</em> en una llista d’espera durant tota l’època actual fent la resincronització amb el nou fragment. Després el node es pot convertir en un validador elegible i unir-se al <em>shard</em> efectivament.<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a></p>
<figure>
<img src="shardred.png" id="fig:shardred" style="width:40.0%" alt="" /><figcaption>Redundància als <em>shards</em> entre èpoques. (Font: Captura de <span class="citation" data-cites="elrond2019"></span>).</figcaption>
</figure>
<h2 id="sec:transshards">Transaccions entre <em>shards</em></h2>
<p>Com a exemple de com s’executen les transaccions entre diferents <em>shards</em> i com es comuniquen amb la <em>metachain</em>, emprarem una <strong>arquitectura amb només dos <em>shards</em></strong>. Imaginem que un usuari des del seu <em>wallet</em> amb una adreça dins del <em>shard</em> 0 envia EGLD a l’adreça d’altre <em>wallet</em> que es troba en el <em>shard</em> 1 (Fig. <a href="#fig:shardingtrans" data-reference-type="ref" data-reference="fig:shardingtrans">7</a>). L’estructura dels blocs estarà formada per <span class="citation" data-cites="elrond2019"></span>:</p>
<ul>
<li><p><strong>Capçalera</strong> (<em>header</em>): Conté la informació referent al bloc (<em>nonce</em>, <em>round</em>, <em>proposer</em>, <em>validators</em>, <em>timestamps</em>, etc.).</p></li>
<li><p><strong>Llista de miniblocs</strong>: Per a cada <em>shard</em> hi haurà un minibloc que contindrà transaccions a executar. S’ha de destacar que un minibloc és la unitat atòmica de processament, això significa que o es processen totes les transaccions del minibloc o no es processa cap (en aquest darrer cas, es posposarà l’execució al següent <em>round</em>). Dins d’un mateix bloc, poden aparèixer diversos miniblocs amb el mateix emissor i receptor (no hi ha cap limitació). Per exemple, en aquest cas simple amb només dos <em>shards</em>, un bloc en el <em>shard</em> 0 contindrà bàsicament tres tipus de miniblocs:</p>
<ul>
<li><p>Minibloc 0: Conté les transaccions on les adreces del remitent i del destinatari són al <em>shard</em> 0.</p></li>
<li><p>Minibloc 1: Conté les transaccions on les adreces del remitent són al <em>shard</em> 0 i les del destinatari al <em>shard</em> 1.</p></li>
<li><p>Minibloc 2: Conté les transaccions on les adreces del remitent són al <em>shard</em> 1 i les del destinatari al <em>shard</em> 0.</p></li>
</ul></li>
</ul>
<figure>
<img src="shardtrans.png" id="fig:shardingtrans" style="width:90.0%" alt="" /><figcaption>Exemple d’execució de transacció entre dos <em>shards</em>. (Font: Fig. 4 de <span class="citation" data-cites="elrond2019"></span>).</figcaption>
</figure>
<p>Observem en la <strong>Fig. <a href="#fig:shardingtrans" data-reference-type="ref" data-reference="fig:shardingtrans">7</a></strong> un exemple de transacció asíncrona amb dos <em>shards</em> implicats. Després d’arribar la transacció al <em>shard</em> 0 (<strong><em>step</em> 1</strong>), la capçalera del bloc i els miniblocs s’envien a la <em>metachain</em>. Aquesta darrera dona fe<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> d’aquest bloc del <em>shard</em> 0 creant un nou bloc a la metacadena que conté la següent informació sobre tots els miniblocs: identificador del <em>shard</em> remitent, identificador del <em>shard</em> receptor i <em>hash</em> del minibloc (<strong><em>step</em> 2</strong>). El <em>shard</em> 1 veu el minibloc a la <em>metachain</em> i obté el seu <em>hash</em> del metabloc (<strong><em>step</em> 3</strong>), per després demanar el minibloc al <em>shard</em> 0 i executar-lo altra vegada (<strong><em>step</em> 4</strong>). Finalment, el <em>shard</em> 1 envia el resultat a la <em>metachain</em> que valida la transacció creuada (<strong><em>step</em> 5</strong>). En aquest punt la transacció ja es pot considerar finalitzada.</p>
<h2 id="la-màquina-virtual-delrond"><em>La màquina virtual d’Elrond</em></h2>
<p>La màquina virtual d’Elrond executa WebAssembly (Wasm)<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>, un llenguatge de baix nivell amb format binari compacte anomenat <em>bytecode</em> <span class="citation" data-cites="mozilla2021"></span>. El fet que executi Wasm implica que es puguin escriure contractes intel·ligents en qualsevol llenguatge que sigui possible compilar cap a <em>bytecode</em> (C, C++, C#, Rust, Go, TypeScript, etc.). Tot i això, Elrond recomana als desenvolupadors que emprin Rust i els hi faciliten un <em>framework</em><a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> per a aquest llenguatge, així com un <em>plugin</em> per a l’IDE de Microsoft Visual Studio Code<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>. Entre les característiques a destacar de la màquina virtual d’Elrond <span class="citation" data-cites="elrond2022"></span><span class="citation" data-cites="mincub2020"></span>:</p>
<ul>
<li><p><strong>Sense estat</strong>: Això significa que, quan un <em>smart contract</em> sigui executat, es guardarà la informació en una estructura de dades transitòria, en lloc d’escriure directament en l’estat. Quan acabi l’execució, si aquesta és exitosa, l’API aplicarà els canvis a l’emmagatzematge i/o a la cadena de blocs.</p></li>
<li><p><strong>Execució fora de procés</strong>: La màquina virtual serà executada en un procés independent i el node en si mateix en un altre, tot i que compartiran informació a través de canonades (<em>pipes</em>) anònimes a memòria principal. A més, el <em>bytecode</em> s’executarà en un entorn aïllat i la memòria del procés de la màquina virtual serà inaccessible.</p></li>
<li><p><strong>Motor d’execució ràpida</strong>: Com a motor d’execució s’empra una versió modificada per Elrond de Wasmer<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>, una implementació de Wasm<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> de codi obert escrita en Rust per entorns servidor. Per les característiques de Wasmer, l’execució dels contractes intel·ligents es fa a una velocitat gairebé nadiua.</p></li>
<li><p><strong>Trucades asíncrones entre contractes</strong>: Els contractes intel·ligents poden executar trucades entre ells fent servir l’API de la màquina virtual. Com hem vist, la xarxa d’Elrond es fragmenta adaptativament, el que pot fer que es truqui a un <em>smart contract</em> que es trobi en un altre <em>shard</em>. En aquest cas l’execució serà asíncrona. Si ambdós estan en el mateix fragment, l’execució serà síncrona. Tot això es fa de forma transparent per al desenvolupador.</p></li>
</ul>
<p>En el cas general, els contractes intel·ligents seran compilats generant un arxiu WASM que serà desplegat en alguna de les xarxes d’Elrond.</p>
<h2 id="execució-de-contractes-intelligents-en-larquitectura-amb-shards">Execució de contractes intel·ligents en l’arquitectura amb <em>shards</em></h2>
<p>Altre punt important a destacar és l’execució dels <em>smart contracts</em> en aquesta arquitectura fragmentada. Elrond ho solventa amb una solució amb execució asíncrona entre els <em>shards</em> <span class="citation" data-cites="elrond2019"></span>.</p>
<p>El procés comença quan l’usuari crea una transacció per executar un contracte intel·ligent. Si el contracte intel·ligent no és ubicat en el mateix <em>shard</em>, el cost de la transacció es lleva del compte del remitent i s’afegeix a un minibloc –segons correspongui a l’adreça del receptor– del seu <em>shard</em>. La transacció és “notaritzada” per la <em>metachain</em> i després processada pel <em>shard</em> de destí. Al fragment de destí, la transacció es tracta com una invocació del mètode del contracte intel·ligent, ja que és on es troba (l’adreça de destí és la del <em>smart contract</em>). Per a la trucada del contracte intel·ligent, es crea un compte temporal que suplanta el compte del remitent, amb el saldo del valor de la transacció i es crida el contracte intel·ligent. Després de l’execució, el contracte intel·ligent pot retornar resultats que afecten diversos comptes en diferents <em>shards</em>. Els resultats que afecten els comptes del <em>shard</em> del contracte intel·ligent s’executen a la mateixa ronda, en cas contrari es crearan transaccions <em>Smart Contract Result</em> (SCR). En aquest darrer cas, es creen miniblocs SCR per a cada <em>shard</em> de destí que posteriorment són “notaritzats” per la <em>metachain</em> (de la mateixa manera que hem vist a la secció <a href="#sec:transshards" data-reference-type="ref" data-reference="sec:transshards">2.6</a> per a les transaccions entre <em>shards</em>). Finalment, són processats pels <em>shards</em> respectius (on resideixen els comptes de destí). En el cas que un contracte intel·ligent truqui dinàmicament a un altre que es trobi en un <em>shard</em> diferent, aquesta trucada es desaria com a resultat intermedi i es tractaria de la mateixa manera que per als comptes. Aquesta solució necessitarà <strong>almenys 5 rondes per completar-se</strong>, però té els avantatges de què <strong>no es necessita cap bloqueig ni moure estats entre <em>shards</em></strong>.</p>
<h2 id="sub:xarxes">Xarxes Elrond disponibles</h2>
<p>En Elrond tenim tres xarxes disponibles:</p>
<ul>
<li><p><strong><em>Mainnet</em></strong>: És la xarxa en producció d’Elrond. És a dir, es fan transaccions reals amb el pertinent cost econòmic. En el moment de redactar la present secció, té més de 3000 nodes validadors distribuïts en 3 <em>shards</em> i en una <em>metachain</em>.</p></li>
<li><p><strong><em>Devnet</em></strong>: És una xarxa pública de proves mantinguda per la comunitat d’Elrond on qualsevol desenvolupador pot provar els seus contractes intel·ligents i DApps en un entorn real. Té uns 300 nodes validadors distribuïts en 3 <em>shards</em> i en una <em>metachain</em>. <strong>En el present treball empraré aquesta xarxa</strong>, en detriment de <em>testnet</em>, per tenir més estabilitat.</p></li>
<li><p><strong><em>Testnet</em></strong>: També pública i mantinguda per la comunitat d’Elrond, però s’empra per fer proves de futures millores i rendiment <span class="citation" data-cites="mincub2019-2"></span> (això implica que el <em>blockchain</em> es pot reiniciar<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a>). Té uns 2000 nodes repartits en 3 <em>shards</em> i en una <em>metachain</em>.</p></li>
</ul>
<figure>
<img src="mainnet.png" id="fig:mainnet" alt="" /><figcaption><em>Mainnet</em>: <a href="https://explorer.elrond.com/validators">https://explorer.elrond.com/validators</a></figcaption>
</figure>
<figure>
<img src="devnet.png" id="fig:devnet" alt="" /><figcaption><em>Devnet</em>: <a href="https://devnet-explorer.elrond.com/nodes">https://devnet-explorer.elrond.com/nodes</a></figcaption>
</figure>
<figure>
<img src="testnet.png" id="fig:testnet" alt="" /><figcaption><em>Testnet</em>: <a href="https://testnet-explorer.elrond.com/nodes">https://testnet-explorer.elrond.com/nodes</a></figcaption>
</figure>
<h2 id="muntar-un-node-validador">Muntar un node validador</h2>
<p>Com ja s’ha deixat entreveure, la <strong>xarxa d’Elrond</strong> és composta pels seus nodes i per la interconnectivitat entre ells. Com s’ha dit en la secció <a href="#sub:entitat" data-reference-type="ref" data-reference="sub:entitat">2.2</a>, per <strong>node</strong> s’entendrà qualsevol instància del programari de codi obert desenvolupat per Elrond per a aquesta tasca <a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>. A més a més, qualsevol persona o entitat responsable de la gestió d’un o més d’aquests nodes es coneix com a “<strong>operador de nodes</strong>”. Com també s’ha vist, la xarxa és dissenyada per ser segura i per poder balancejar la seva càrrega. Així, quan un nou node s’uneix a la xarxa aporta més seguretat i eficiència. I la xarxa premiarà els nodes per la seva aportació, creant-se així una espècie de simbiosi.</p>
<p><strong>Elrond és una xarxa descentralitzada de <em>blockchain</em></strong>, és a dir, nodes de procedència desconeguda s’uneixen per crear seqüencialment blocs amb una cadència determinada. Els blocs contenen operacions que es realitzaren a petició dels usuaris de la xarxa pagant unes taxes (<em>fees</em>) per l’execució d’aquestes. Entre les operacions es troben la transferència de <em>tokens</em> entre comptes o l’execució de contractes intel·ligents (totes les operacions prenen la forma de transaccions). Per tant, es defineix així un llibre de comptabilitat distribuït que no depèn de cap entitat central.</p>
<p>Els nodes que estan autoritzats a prendre part en l’algorisme de consens s’anomenen <strong>validadors</strong>. Com que són els que veritablement produeixen i validen blocs, són els únics nodes recompensats amb EGLD per la seva contribució. Com ja vàrem dir en la secció <a href="#sub:entitat" data-reference-type="ref" data-reference="sub:entitat">2.2</a>, per assegurar el bon comportament dels validadors han de tenir bloquejats 2500 EGLD (<em>stake</em>). Els nodes sense <em>stake</em> s’anomenen <strong>observadors</strong> (no participen en el consens i no guanyen recompenses). Si el validador no funciona correctament (desconnexions de la xarxa en mig del procés de consens, accions malicioses, etc.) serà “multat” perdent EGLD (<em>stake slashing</em>) o fins i tot, en casos greus, se li llevarà l’estatus de validador (el node passarà a l’estat “<em>jailed</em>” i no es triarà per al consens si no paga una multa de 2,5 EGLD). Si això succeeix també davallarà la seva qualificació (<em>rating score</em>). Com que aquesta puntuació defineix la fiabilitat del validador, serà considerada per l’algorisme de selecció de nodes per triar el grup de consens. Així, s’afavoreix l’elecció de nodes amb qualificacions altes, també se’ls hi premiarà amb més EGLD.</p>
<p>Els requisits mínims del sistema són:</p>
<ul>
<li><p>4 CPU dedicades (Intel/AMD amb <em>flags</em> SSE4.1 i SSE4.2 activats).</p></li>
<li><p>8 GB de RAM.</p></li>
<li><p>Disc dur SSD amb 200 GB d’espai lliure.</p></li>
<li><p>Connexió a Internet de 100 Mbit/s sempre activa (mínim 4 TB/mes).</p></li>
<li><p>Sistema operatiu Linux<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a>/MacOS.</p></li>
</ul>
<p>Com podem observar, són característiques d’un PC/Mac convencional en l’actualitat (i no d’ordinadors amb potents targetes gràfiques dedicades com passa amb el PoW de Bitcoin). No és l’objectiu del present treball, però guies com-es-fa<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a> per instal·lar el programari per muntar un node validador en la xarxa Elrond es poden trobar a <span class="citation" data-cites="elrond2022"></span> o <span class="citation" data-cites="penalver2019"></span>.<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a></p>
<h2 id="carteres">Carteres</h2>
<p>Com ja s’ha comentat en la secció <a href="#sub:context" data-reference-type="ref" data-reference="sub:context">1.1</a> existeixen diferents carteres que es poden fer servir per enviar, rebre i emmagatzemar EGLD de forma segura.</p>
<ul>
<li><p><strong>Moneder web</strong>. Existeix una versió per a cadascuna de les xarxes:<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a></p>
<ul>
<li><p><em>Mainnet</em>: Accesible a <a href="https://wallet.elrond.com/">https://wallet.elrond.com/</a>.</p></li>
<li><p><em>Devnet</em>: Accesible a <a href="https://devnet-wallet.elrond.com/">https://devnet-wallet.elrond.com/</a>.</p></li>
<li><p><em>Testnet</em>: Accesible a <a href="https://testnet-wallet.elrond.com/">https://testnet-wallet.elrond.com/</a>.</p></li>
</ul>
<p>Tampoc és l’objectiu del present treball explicar com crear un moneder, però una guia com-es-fa es pot trobar en <span class="citation" data-cites="elrond2022"></span>. Quan es crea s’haurà d’introduir una contrasenya<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a> i se’ns donaran 24 paraules secretes (que permeten generar la clau privada). El procés finalitzarà descarregant un fitxer json (<em>keystore file</em>). Com es veu en la Fig. <a href="#fig:webwallet" data-reference-type="ref" data-reference="fig:webwallet">11</a>, podem accedir al nostre moneder amb aquest arxiu json i introduint la contrasenya que hem creat (nombre 1 en la Fig. <a href="#fig:webwallet" data-reference-type="ref" data-reference="fig:webwallet">11</a>). Una altra opció és generar un fitxer “PEM” (<em>Privacy Enhanced Mail</em>) amb la nostra clau privada i emprar-lo per accedir (nombre 3 en la Fig. <a href="#fig:webwallet" data-reference-type="ref" data-reference="fig:webwallet">11</a>), que es pot generar emprant la utilitat d’Elrond “<em>erdpy</em>” (s’hauran d’introduir les 24 paraules secretes separades per un espai):</p>
<pre><code>[
    basicstyle=\footnotesize,
]
erdpy --verbose wallet derive testdev-wallet.pem --mnemonic</code></pre>
<p>Finalment, es pot iniciar sessió amb un moneder de maquinari (per exemple amb un Ledger Nano S) o llegint un codi QR amb l’aplicació mòbil Maiar (nombres 2 i 4 en la Fig. <a href="#fig:webwallet" data-reference-type="ref" data-reference="fig:webwallet">11</a>, respectivament).</p>
<figure>
<img src="webwallet.png" id="fig:webwallet" style="width:50.0%" alt="" /><figcaption>Mètodes d’accés al moneder web.</figcaption>
</figure></li>
<li><p><strong>Maiar DeFi Wallet</strong>. Es tracta d’una extensió per a navegadors de la família de Chrome<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a>. El funcionament i prestacions és similar al moneder web (fent la comparació amb la xarxa Ethereum, seria com l’extensió “Metamask”<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a>). En la Fig. <a href="#fig:maiarwalletb" data-reference-type="ref" data-reference="fig:maiarwalletb">13</a> es pot comprovar que també es pot canviar entre les tres xarxes disponibles (llista desplegable a dalt a la dreta que diu “Main”).</p>
<figure>
<img src="maiarextensio.png" id="fig:maiarwalleta" alt="" />
</figure>
<figure>
<img src="maiarextensio2.png" id="fig:maiarwalletb" alt="" />
</figure></li>
<li><p><strong><em>Maiar</em></strong><a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a>. DApp que implementa una cartera digital per dispositius iOS i Android. Permet enviar o rebre diners emprant el número de telèfon mòbil o un <em>herotag</em> (una espècie de nom d’usuari que es pot emprar en lloc de la teva adreça). És completament descentralitzada, sense custòdia i Elrond no té accés als fons de l’usuari en cap moment. Es pot treballar amb criptoactius com Elrond Gold (EGLD), Binance (BNB), Ethereum (ETH) o Bitcoin (BTC). Com no pot ser d’altra forma, es disposen de mecanismes de recuperació (una frase) per rescatar els fons en cas de pèrdua o robatori del nostre telèfon intel·ligent. No he trobat forma de connectar a la <em>devnet</em> o <em>testnet</em> des de Maiar, penso que déu ser així perquè és principalment dissenyada per treballar amb la <em>mainnet</em>. Òbviament, aquesta DApp és pensada per comprar criptoactius a través de pagaments amb targeta bancària o transferències SEPA (s’han d’emprar passarel·les en ambdós casos). Curiosament, no permet fer <em>swaps</em> entre criptoactius (només es poden fer des de Maiar Exchange).</p>
<figure>
<img src="maiarapp.png" id="fig:maiarapp" style="width:30.0%" alt="" /><figcaption>Maiar per iPhone.</figcaption>
</figure></li>
<li><p><strong><em>Webhooks</em></strong>. Són enllaços que criden<a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a> a la cartera de l’usuari perquè iniciï sessió o ompli un formulari per realitzar una transacció de pagament amb els arguments proporcionats. Un cop realitzada l’acció, l’usuari és redirigit a un URL amb informació d’estat d’èxit o d’error. Un exemple seria <span class="citation" data-cites="elrond2022"></span>:</p>
<pre><code>[
    basicstyle=\scriptsize,
]
https://wallet.elrond.com/hook/login?callbackUrl=https://example.com/</code></pre></li>
<li><p><strong><em>Ledger</em></strong>. És l’opció recomanada per Elrond si es fa feina amb grans quantitats d’EGLD. Podem emmagatzemar els nostres criptoactius en moneders de maquinari com són els dispositius <em>Ledger Nano S</em> o <em>Ledger Nano X</em>.</p></li>
</ul>
<h2 id="subsec:maiarexchange">Maiar Exchange</h2>
<p>Maiar Exchange<a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a> és un DEX (<em>Decentralized EXchange</em>) basat en <em>liquidity pools</em> –fons de liquiditat– creat per Elrond emprant la seva arquitectura escalable. Permet els usuaris efectuar la compravenda de criptoactius (<em>trading</em>). A més a més, els usuaris poden convertir-se en proveïdors de liquiditat aportant els seus actius (guanyant <em>tokens</em> MEX per cada transacció d’intercanvi realitzada segons el parell de <em>tokens</em> aportats com a reserva). MEX és el <em>token</em> nadiu de Maiar Exhange. A part de tenir la funció d’incentivar els usuaris perquè proporcionin liquiditat, també serà emprat en processos de governança. Així, ens trobem davant d’un Exchange de <em>criptoactius</em> sense intermediaris, cosa que abarateix els costos de les transaccions i dels <em>swaps</em>.</p>
<p>Entre el que podem fer amb Maiar Exchange vull destacar <span class="citation" data-cites="everstake2021"></span><span class="citation" data-cites="elrond2021"></span>:</p>
<ul>
<li><p><strong><em>Swapping</em></strong> (intercanvi): Consisteix a intercanviar un criptoactiu per un altre. El mecanisme d’intercanvi consisteix en permutar els actius de l’usuari amb els <em>liquidity pools</em> (fons de liquiditat), i no directament amb altres participants en el mercat. Els preus dels actius es fixen a partir d’una fórmula matemàtica del que s’anomena <em>Automated Market Making</em>. En lloc d’utilitzar un llibre de comptabilitat com en un intercanvi tradicional, els actius tenen uns preus calculats segons un algorisme. Elrond empra la fórmula <span class="math inline"><em>x</em> * <em>y</em> = <em>k</em></span>, on <span class="math inline"><em>x</em></span> és la quantitat d’un token al <em>liquidity pool</em> i <span class="math inline"><em>y</em></span> és la quantitat de l’altre. <span class="math inline"><em>k</em></span> és una constant fixa, el que significa que la liquiditat total del grup sempre romandrà en la mateixa proporció. Hi ha una comissió del 0,3% per intercanviar tokens (el 0,25% pels proveïdors de liquiditat proporcional a la seva contribució a les reserves de liquiditat i amb la resta es compraran MEX que es cremaran). En la data de redacció d’aquesta secció, els actius amb els que es poden fer intercanvis són MEX, USDC, RIDE, CRU, ZPAY, ISET, AERO, EFFORT i WAM contra EGLD. Això significa que hi ha fons de liquiditat MEX-EGLD, USDC-EGLD, etc.</p></li>
<li><p><em><strong>Liquidity Pools</strong></em>: Són reserves de tokens que es troben en contractes intel·ligents del DEX i estan disponibles perquè els usuaris facin intercanvis. Aquests tokens els proporcionen proveïdors de fons de liquiditat amb els quals els usuaris de la plataforma poden negociar. Els proveïdors són incentivats amb recompenses (tokens MEX) pels intercanvis que es produeixen en els seus <em>pools</em> (segons s’ha explicat en el punt anterior). S’ha de destacar que els proveïdors de liquiditat en qualsevol moment poden retirar els fons que han dipositat (independentment de les condicions del mercat).</p></li>
<li><p><em><strong>Farming</strong></em><a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a>: Consisteix en el fet que els usuaris bloquegin la seva liquiditat per obtenir recompenses. Si posem els nostres actius en un <em>liquidity pool</em> obtindrem les recompenses descrites en els apartats anteriors (això és el <em><strong>farming</strong></em> i és el que s’ha descrit en el punt d’adalt). Però hi ha també l’opció de posar els nostres <em>liquidity pools</em> en <em><strong>staking</strong></em>, el que significa que no els podrem retirar durant un temps definit a canvi d’aconseguir una recompensa major.</p></li>
</ul>
<figure>
<img src="maiardex.png" id="fig:maiardex" style="width:75.0%" alt="" /><figcaption>Maiar Exchange.</figcaption>
</figure>
<h2 id="sub:altres">Altres punts destacables</h2>
<ul>
<li><p><strong>Camps d’una transacció</strong>:</p>
<p>Els camps d’una transacció sense signar en la xarxa Elrond són <span class="citation" data-cites="elrond2022"></span>:</p>
<ul>
<li><p><strong>nonce</strong> (<em>number</em>): Nombre de seqüència del compte. És obligatori.</p></li>
<li><p><strong>value</strong> (<em>string</em>): El valor a transferir. És obligatori (pot ser 0).</p></li>
<li><p><strong>receiver</strong> (<em>string</em>): Adreça del receptor (format <em>bech32</em>). És obligatori.</p></li>
<li><p><strong>sender</strong> (<em>string</em>): Adreça del remitent (format <em>bech32</em>). És obligatori.</p></li>
<li><p><strong>gasPrice</strong> (<em>number</em>): El preu del <em>gas</em> que s’utilitzarà en la transacció. És obligatori.</p></li>
<li><p><strong>gasLimit</strong> (<em>number</em>): El nombre màxim d’unitats de <em>gas</em> assignades per a la transacció. És obligatori.</p></li>
<li><p><strong>data</strong> (<em>string</em>): Informació arbitrària sobre la transacció, codificada en base64 . No és obligatori.</p></li>
<li><p><strong>chainID</strong> (<em>string</em>): Identificador de cadena. ‘D’ per a la xarxa <em>devnet</em>, ‘T’ per a <em>testnet</em> i ‘1’ per a la <em>mainnet</em>. És obligatori.</p></li>
<li><p><strong>version</strong> (<em>number</em>): La versió de la transacció (p. ex. 1). És obligatori.</p></li>
</ul>
<p>En les transaccions que han de ser signades, amb la clau pública del remitent (amb l’algorisme Ed2519), s’ha d’afegir el següent camp:</p>
<ul>
<li><p><strong>signature</strong> (<em>string</em>): Signatura digital que consta de 128 caràcters hexadecimals (64 bytes en representació en brut).</p></li>
</ul>
<p>Hi ha disponibles diferents eines per realitzar la signatura des de la <em>shell</em> de Linux i des del codi font: <em>erdpy</em>, <em>erdwalletjs-cli</em> o <em>elrond-core-js</em>.</p></li>
<li><p><strong>Decimals per treballar amb EGLD</strong>: Un EGLD és configurat per tenir 18 decimals. Així, per exemple 2,5 EGLD tendrien un valor de <span class="math inline">2, 5 * 10<sup>18</sup> = 2500000000000000000</span> wei (seguint l’estàndard de 18 decimals dels tokens ERC20). L’usuari quan creï tokens ESDT podrà definir el seu nombre de decimals (amb un màxim de 18).</p></li>
<li><p><strong>Costos de processament</strong> <span class="citation" data-cites="elrond2022"></span>: Una transacció en la xarxa Elrond té un cost de processament (<em>processing cost</em>), que s’expressa com una quantitat d’unitats de <em>gas</em>. Quan es llança una transacció s’ha de proporcionar un <em>gasLimit</em>, que és el cost màxim que estem disposats a assumir. El <strong>consum real de gas</strong> (<em>actual gas consumption</em> o també <em>used gas</em>) és la quantitat real que s’ha consumit del <em>gasLimit</em> requerida perquè la xarxa processi la transacció. Per calcular aquest darrer, la xarxa el divideix en dos components d’utilització del <em>gas</em> <span class="citation" data-cites="elrond2022"></span>:</p>
<ul>
<li><p><strong>Moviment de valors i tractament de dades</strong>: Això seria per exemple una transferència d’EGLD entre adreces. El cost es calcula amb la fórmula:</p>
<pre><code>[
    basicstyle=\tiny,
]
tx.gasLimit = 
    networkConfig.erd_min_gas_limit + 
    networkConfig.erd_gas_per_data_byte * lengthOf(tx.data)
Nota:
networkConfig.erd_min_gas_limit &lt;= tx.gasLimit i
tx.gasLimit &lt;= networkConfig.erd_max_gas_per_transaction</code></pre></li>
<li><p><strong>Execució de contracte intel·ligent</strong>: Una trucada a un <em>smart contract</em> requeriria aquest i l’anterior. El cost és més difícil de determinar, ja que depèn del codi font concret del contracte intel·ligent. Es solen emprar simulacions i estimacions.</p></li>
</ul>
<p>Finalment, la <strong>tarifa de processament</strong> (<em>processing fee</em>) es calcula amb respecte de l’<em>actual gas consumption</em> i dels seus dos components. Per a un moviment de valors i tractament de dades s’especifica en la transacció un <em>gas price per gas unit</em> (que ha de ser igual o superior al paràmetre de la xarxa <span class="math inline">$erdmin\textunderscore  gas\textunderscore price$</span>). Per a l’execució d’un contracte intel·ligent el <em>gas price per gas unit</em> es calcula respecte a un altre paràmetre de xarxa anomenat <span class="math inline">$erd\textunderscore gas\textunderscore price\textunderscore modifier$</span>:</p>
<pre><code>[
    basicstyle=\tiny,
]
value_movement_and_data_handling_price_per_unit = tx.GasPrice
contract_execution_price_per_unit =
        tx.GasPrice * networkConfig.erd_gas_price_modifier</code></pre></li>
<li><p><strong>ESDT (<em>Elrond Standard Digital Token</em>)</strong>: La xarxa Elrond admet de forma nadiua l’emissió de <em>tokens</em> creats pels usuaris (des de codi, des d’un contracte intel·ligent o des de la <em>web wallet</em>). Això implica que no és necessari emprar contractes com els de tipus ERC20 de la xarxa Ethereum. Ja que el suport és nadiu, no es requereix processament extra per part de la màquina virtual (amb el que són tan eficients com el mateix EGLD).</p></li>
<li><p><strong>NFT (<em>Non-Fungible Token</em>) i SFT (<em>Semi-Fungible Token</em>)</strong>: Suport nadiu d’NFT i SFT afegint metadades i atributs a sobre de l’ESDT. Així, són bastant similars a aquests darrers però amb atributs extra (<em>NFT Name</em>, <em>Quantity</em>, <em>Royalties</em>, <em>Hash</em>, <em>Attributes</em> i <em>URI</em>).</p></li>
<li><p><strong><em>Local Testnet</em></strong>: Es pot configurar una <em>testnet</em> en local per fer proves i <em>debugging</em> del codi. Es pot emprar amb l’eina <em>erdpy</em> i conté nodes validadors, nodes observadors, un <em>seed node</em> i un <em>Elrond Proxy</em>.</p></li>
<li><p><strong>API REST</strong>: Té dues capes a les quals es pot accedir públicament:</p>
<ul>
<li><p><strong>https://gateway.elrond.com</strong>: La de més baix nivell. Gestiona l’encaminament de les peticions de forma transparent segons els mecanismes de fragmentació que s’han descrit en els apartats anteriors.</p></li>
<li><p><strong>https://api.elrond.com</strong>: La de més alt nivell (empra els serveis de la capa anterior). Aporta serveis com un mecanisme de memòria cau, cerques històriques amb Elasticsearch<a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a>, etc.</p></li>
</ul></li>
</ul>
<h1 id="sec:testdex">testDEX</h1>
<h2 id="anàlisi">Anàlisi</h2>
<h3 id="subsub:dexamm">DEX i AMM</h3>
<p>Un <strong><em>Decentralized exchange</em> (DEX)</strong> és un mercat on els negociants de criptomonedes fan transaccions directament entre ells –d’igual a igual (<em>peer-to-peer</em>)– sense haver de lliurar la gestió dels seus fons a un intermediari <span class="citation" data-cites="cointelegraph"></span>. És a dir, són dissenyats per eliminar qualsevol autoritat de supervisió en els intercanvis (<em>swaps</em>) de criptoactius, evitant que s’hagin d’enviar dades de caràcter personal (noms, adreces, etc.). Per executar les ordres d’intercanvi sense intermediaris s’empren contractes intel·ligents. Això xoca amb el concepte de <em><strong>Centralized exchange</strong></em> on la gestió és responsabilitat d’una organització, com ara un banc o qualsevol altra corporació, que requerirà que els seus usuaris estiguin identificats i que custodiaran els actius d’aquests (òbviament cercant un benefici econòmic).</p>
<p>En el present treball ens centrarem en una versió simplificada de DEX fent servir <em>Automated Market Makers</em> (AMM). Els diferents tipus de DEX es poden observar en la figura <a href="#fig:dextypes" data-reference-type="ref" data-reference="fig:dextypes">16</a>.</p>
<figure>
<img src="DEXtypes.png" id="fig:dextypes" style="width:95.0%" alt="" /><figcaption>Tipus de DEX. (Font: <span class="citation" data-cites="cointelegraph"></span>).</figcaption>
</figure>
<p>En <span class="citation" data-cites="delarosa"></span> es descriu que una de les formes de prescindir del llibre d’ordres d’un <em>Exchange</em> tradicional és emprant AMM. Aquests protocols fan servir una fórmula matemàtica per calcular el preu dels actius d’un fons de liquiditat segons l’estat d’aquest (tal qual hem vist en la secció <a href="#subsec:maiarexchange" data-reference-type="ref" data-reference="subsec:maiarexchange">2.12</a>). Quan es vulgui fer un intercanvi entre criptoactius s’interactuarà directament amb un contracte intel·ligent que determinarà el preu de compra de l’actiu destí segons l’estat del fons de liquiditat. La fórmula per calcular això, també vista en la secció <a href="#subsec:maiarexchange" data-reference-type="ref" data-reference="subsec:maiarexchange">2.12</a>, és: <br /><span class="math display"><em>x</em> * <em>y</em> = <em>k</em></span><br /> Amb <span class="math inline"><em>x</em></span> la quantitat d’un token al fons de liquiditat, <span class="math inline"><em>y</em></span> la quantitat de l’altre i <span class="math inline"><em>k</em></span> una constant fixa per mantenir la proporcionalitat entre el parell de <em>tokens</em>.</p>
<p>Imaginem que volem intercanviar una quantitat del primer token <span class="math inline"><em>t</em><sub><em>x</em></sub></span> i volen conèixer la quantitat <span class="math inline"><em>t</em><sub><em>y</em></sub></span> que rebrem a canvi: <br /><span class="math display">(<em>x</em> + <em>t</em><sub><em>x</em></sub>) * (<em>y</em> − <em>t</em><sub><em>y</em></sub>) = <em>k</em></span><br /> <br /><span class="math display">$$(y - t_y) = \frac{k}{x + t_x}$$</span><br /> <br /><span class="math display">$$t_y = y - \frac{k}{x + t_x}$$</span><br /> <br /><span class="math display">$$t_y = \frac{y * x + y * t_x - k}{x + t_x}$$</span><br /> <br /><span class="math display">$$t_y = \frac{y * t_x}{x + t_x}$$</span><br /></p>
<p>Si per contra volem donar <span class="math inline"><em>t</em><sub><em>y</em></sub></span> i rebre <span class="math inline"><em>t</em><sub><em>x</em></sub></span>: <br /><span class="math display">(<em>x</em> − <em>t</em><sub><em>x</em></sub>) * (<em>y</em> + <em>t</em><sub><em>y</em></sub>) = <em>k</em></span><br /> <br /><span class="math display">$$(x - t_x) = \frac{k}{y + t_y}$$</span><br /> <br /><span class="math display">$$t_x = x - \frac{k}{y + t_y}$$</span><br /> <br /><span class="math display">$$t_x = \frac{x * y + x * t_y - k}{y + t_y}$$</span><br /> <br /><span class="math display">$$t_x = \frac{x * t_y}{y + t_y}$$</span><br /></p>
<p>Aquesta situació seria utòpica ja que no se pagaria cap taxa (<em>fee</em>). Si afegim una comissió, les fórmules d’abans quedarien de la següent forma: <br /><span class="math display">$$t'_x = x - \frac{k}{y + t_y * (1 - fee)} = \frac{x * y + x * t_y *(1 - fee) - k}{y + t_y * (1 - fee)}$$</span><br /> <br /><span class="math display">$$t'_x = \frac{x * t_y *(1 - fee)}{y + t_y * (1 - fee)}$$</span><br /> <br /><span class="math display">$$t'_y = y - \frac{k}{x + t_x * (1 - fee)} = \frac{y * x + y * t_x * (1 - fee) - k}{x + t_x * (1 - fee)}$$</span><br /> <br /><span class="math display">$$t'_y = \frac{y * t_x * (1 - fee)}{x + t_x * (1 - fee)}$$</span><br /></p>
<p>Així, si es realitzes el <em>swap</em>, el que quedaria acumulat en el contracte intel·ligent seria: <br /><span class="math display"><em>a</em><em>c</em><em>u</em><em>m</em><em>u</em><em>l</em><em>a</em><em>t</em><sub><em>x</em></sub> = <em>t</em><sub><em>x</em></sub> − <em>t</em>′<sub><em>x</em></sub></span><br /> <br /><span class="math display"><em>a</em><em>c</em><em>u</em><em>m</em><em>u</em><em>l</em><em>a</em><em>t</em><sub><em>y</em></sub> = <em>t</em><sub><em>y</em></sub> − <em>t</em>′<sub><em>y</em></sub></span><br /></p>
<p>Per exemple, imaginem que tenim un fons de liquiditat amb el parell xEGLD-UOC –“UOC” és un ESDT creat per mi– amb 10 xEGLD<a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a> (<span class="math inline"><em>x</em></span>) i 10000 UOC (<span class="math inline"><em>y</em></span>). Així tenim que la constant <span class="math inline"><em>k</em></span> queda com: <br /><span class="math display"><em>k</em> = <em>x</em> * <em>y</em> = 10 * 10000 = 100000</span><br /></p>
<p>Suposem també que volem canviar 1 xEGLD (<span class="math inline"><em>t</em><sub><em>x</em></sub></span>) per UOC (<span class="math inline"><em>t</em><sub><em>y</em></sub></span>) i que hi ha una comissió del 0,5%: <br /><span class="math display">$$t_y = \frac{y * t_x}{x + t_x} = \frac{10000 * 1}{10 + 1} = 909,090909091$$</span><br /></p>
<p><br /><span class="math display">$$t'_y = \frac{y * t_x * (1 - fee)}{x + t_x * (1 - fee)} = \frac{10000 * 1 * (1 - 0,005)}{10 + 1 * (1 - 0,005)} = 904,956798545$$</span><br /></p>
<p><br /><span class="math display"><em>a</em><em>c</em><em>u</em><em>m</em><em>u</em><em>l</em><em>a</em><em>t</em><sub><em>y</em></sub> = <em>t</em><sub><em>y</em></sub> − <em>t</em>′<sub><em>y</em></sub> = 909, 090909091 − 904, 956798545 = 4, 134110546</span><br /></p>
<p><br /><span class="math display"><em>k</em> = (<em>x</em> + <em>t</em><sub><em>x</em></sub>) * (<em>y</em> − <em>t</em><sub><em>y</em></sub>) = (10 + 1) * (10000 − 909, 090909091)=</span><br /> <br /><span class="math display"> = 11 * 9090, 909090909 = 99999, 999999999</span><br /></p>
<p>Si seguim i ara canviem 1000 UOC (<span class="math inline"><em>t</em><sub><em>y</em></sub></span>) per xEGLD (<span class="math inline"><em>t</em><sub><em>x</em></sub></span>): <br /><span class="math display">$$t_x = \frac{x * t_y}{y + t_y} = \frac{11 * 1000}{9090,909090909 + 1000} = 1,09009009$$</span><br /> <br /><span class="math display">$$t'_x = \frac{x * t_y *(1 - fee)}{y + t_y * (1 - fee)} = \frac{11 * 1000 *(1 - 0,0005)}{9090,909090909 + 1000 * (1 - 0,0005)} =$$</span><br /> <br /><span class="math display"> = 1, 089599034</span><br /> <br /><span class="math display"><em>a</em><em>c</em><em>u</em><em>m</em><em>u</em><em>l</em><em>a</em><em>t</em><sub><em>x</em></sub> = <em>t</em><sub><em>x</em></sub> − <em>t</em>′<sub><em>x</em></sub> = 1, 09009009 − 1, 089599034 = 0, 000491056</span><br /></p>
<p><br /><span class="math display"><em>k</em> = (<em>x</em> − <em>t</em><sub><em>x</em></sub>) * (<em>y</em> + <em>t</em><sub><em>y</em></sub>) = (11 − 1, 09009009) * (9090, 909090909 + 1000)=</span><br /> <br /><span class="math display"> = 9, 90990991 * 10090, 909090909 = 100000, 000000908</span><br /></p>
<p>A tot això se li ha d’afegir una cosa més: <strong>la comissió que pagarà l’usuari a la xarxa Elrond</strong>. En la secció <a href="#sub:altres" data-reference-type="ref" data-reference="sub:altres">2.13</a> s’ha vist que emprar la xarxa Elrond duu associat uns costos pel moviment de valors i tractament de dades (transferim una quantitat de tokens al contracte intel·ligent) i per execució de contracte intel·ligent (el <em>smart contract</em> que implementa l’AMM). Això encarirà l’operació a l’usuari, ja que el codi que s’executa dins aquest contracte influirà en el cost.</p>
<p>Finalment, es pot observar que <strong>l’arrodoniment provoca que la constant <span class="math inline"><em>k</em></span> es vagi desviant del seu valor original</strong>. El codi del contracte intel·ligent hauria de corregir aquest problema.</p>
<h3 id="les-variants-de-dex-i-amm-a-testdex">Les variants de DEX i AMM a testDEX</h3>
<p>Per assolir els objectius del projecte no fa falta arribar a desenvolupar un DEX de l’estil de Maiar Exchange, Uniswap<a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a> o PancakeSwap<a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a>. Òbviament, un projecte d’aquesta envergadura seria poc realista per una limitació clara de temps. Per exemple, el protocol AMM no és exempt de problemes que s’haurien de tractar <span class="citation" data-cites="vuterin2018"></span>. Així, en aquesta versió inicial faré una sèrie d’adaptacions per ajustar-me al temps disponible:</p>
<ul>
<li><p>El propietari del contracte intel·ligent serà l’únic que pot definir <em>liquidity pools</em>.</p></li>
<li><p>El propietari del contracte serà, per tant, l’únic que rebi les comissions pels <em>swaps</em>.</p></li>
<li><p>Tots els parells tindran com a un dels seus components xEGLD.</p></li>
</ul>
<h3 id="subsub:rfun">Requisits funcionals</h3>
<p>Els requisits funcionals responen a la pregunta “què ha de fer un sistema”. Pel present projecte s’especifiquen els següents:</p>
<ul>
<li><p>RF 1: El sistema permetrà el propietari del contracte intel·ligent dipositar un parell xEGLD-ESDT en el fons de liquiditat des del seu <em>wallet</em>.</p></li>
<li><p>RF 2: El sistema permetrà el propietari del contracte intel·ligent recuperar un parell xEGLD-ESDT del fons de liquiditat cap al seu <em>wallet</em>, que prèviament haurà dipositat.</p></li>
<li><p>RF 3: El sistema permetrà el propietari del contracte definir una taxa (“<em>fee</em>”) que serà gravada als usuaris quan intercanviïn <em>tokens</em>.</p></li>
<li><p>RF 4: El sistema permetrà el propietari recuperar els guanys acumulats al seu contracte intel·ligent resultants del pagament de l’anterior taxa cap al seu <em>wallet</em>.</p></li>
<li><p>RF 5: El sistema permetrà els usuaris fer intercanvis (<em>swaps</em>) entre <em>tokens</em> de la seva cartera amb altres del fons de liquiditat (si existeix el parell adient).</p></li>
<li><p>RF 6: El sistema permetrà els usuaris conèixer els parells donats d’alta al DEX.</p></li>
<li><p>RF 7: El sistema permetrà els usuaris consultar si un parell és disponible per fer <em>swaps</em> (cap dels dos components pot tenir valor 0).</p></li>
<li><p>RF 8: El sistema permetrà els usuaris consultar la constant <span class="math inline"><em>k</em></span> d’un parell en un moment donat.</p></li>
<li><p>RF 9: El sistema mostrarà els preus dels actius en el moment actual (tant de compra com de venda).</p></li>
<li><p>RF 10: El sistema enregistrarà les transaccions.</p></li>
</ul>
<h3 id="subsub:rnofun">Requisits no funcionals</h3>
<p>Els requisits no funcionals responen a la pregunta “com ha de fer un sistema”. Pel present projecte s’especifiquen els següents:</p>
<ul>
<li><p>RNF 1: La informació emprada en el sistema viatjarà per la xarxa emprant protocols segurs.</p></li>
<li><p>RNF 2: El sistema serà accessible des de qualsevol ubicació a través d’Internet.</p></li>
<li><p>RNF 3: Els usuaris del sistema el podran utilitzar amb qualsevol moneder vàlid de la xarxa Elrond.</p></li>
</ul>
<h2 id="disseny">Disseny</h2>
<h3 id="subsub:casosdus">Casos d’ús</h3>
<p>Tindrem un usuari privilegiat (el propietari del contracte intel·ligent) i usuaris genèrics. El primer, òbviament, podrà realitzar també les operacions dels segons. El sistema permetrà només el propietari interactuar amb el contracte intel·ligent de la següent forma:<span><a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a></span></p>
<figure>
<img src="cu_add_claim_liquidity.png" id="fig:addclaimliq" alt="" /><figcaption>Requerimens funcionals 1 i 2.</figcaption>
</figure>
<figure>
<img src="cu_set_fee_claim_earnings.png" id="fig:setfeeclaim" alt="" /><figcaption>Requisits funcionals 3 i 4.</figcaption>
</figure>
<p>Amb les interaccions anteriors es podran <strong>definir <em>liquity pools</em></strong> i una <strong>taxa (<em>fee</em>)</strong> que es cobrarà per les operacions de <em>swap</em>. El següent a definir seran els intercanvis en si mateixos. El criptoactiu de referència serà xEGLD (tots els parells el tindran). Així es podrà passar una determinada quantitat d’un token ESDT a xEGLD. Això també es pot anomenar “<strong>comprar ESDT amb EGLD</strong>”. A la inversa, podrem passar xEGLD a ESDT, que dit d’altra forma seria “<strong>vendre ESDT per EGLD</strong>”. La següent figura ho mostra:</p>
<figure>
<img src="cu_buy_sell1.png" id="fig:cu_buy_sell1" style="width:50.0%" alt="" /><figcaption>RF 5. Operacions de compra i venda de <em>tokens</em> (<em>swaps</em>).</figcaption>
</figure>
<p>Per altra banda, serà necessari que el sistema mostri als usuaris els <strong>parells disponibles per fer intercanvis i si es pot operar amb ells en un moment donat</strong> (requisits funcionals 6 i 7).</p>
<figure>
<img src="cu_get_pairs.png" id="fig:getpairs" alt="" /><figcaption>RF 6.</figcaption>
</figure>
<figure>
<img src="cu_status_pair.png" id="fig:statuspair" alt="" /><figcaption>RF 7.</figcaption>
</figure>
<p>A més, el sistema mostrarà la <strong>constant <span class="math inline"><em>k</em></span> del protocol AMM</strong> (que s’ha de mantenir constant) i el <strong>preu dels actius en el moment actual</strong>. Internament es treballa amb nombres enters on es destinen les 18 posicions a la dreta per a decimals, però realment són nombres enters. Això farà que la constant <span class="math inline"><em>k</em></span> pugui fluctuar i que estigui sotmesa a correccions per mantenir-la en el seu valor inicial. Així mateix, els usuaris hauran de conèixer en temps real els preus de les parelles de tokens. Els casos d’ús sobre aquests punts es mostren en la Fig. <a href="#fig:RRFF8-9" data-reference-type="ref" data-reference="fig:RRFF8-9">[fig:RRFF8-9]</a>.</p>
<figure>
<img src="cu_k_constant.png" id="fig:kconstant" alt="" /><figcaption>RF 8.</figcaption>
</figure>
<figure>
<img src="cu_current_price_EGLD_ESDT.png" id="fig:price_egld_esdt" alt="" /><figcaption>RF 9 (EGLD-ESDT).</figcaption>
</figure>
<figure>
<img src="cu_current_price_ESDT_EGLD.png" id="fig:price_esdt_egld" alt="" /><figcaption>RF 9 (ESDT-EGLD).</figcaption>
</figure>
<figure>
<img src="cu_trans_results.png" id="fig:transresults" style="width:55.0%" alt="" /><figcaption>Requisit funcional 10.</figcaption>
</figure>
<p>Finalment, pel que fa al RF 10 i als <strong>requisits no funcionals</strong>, no cal afegir res ja que formen part de les característiques intrínseques de les tecnologies d’Internet i de la xarxa Elrond.</p>
<h3 id="subsub:sc"><em>Smart contract</em></h3>
<p>Totes les dades dels <em>smart contracts</em> de la xarxa Elrond són disponibles públicament, tot i que pot ser complicat cercar manualment l’emmagatzematge del contracte i per això es solen definir <em>getters</em> públics<a href="#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a>. Quan es desplegui a la xarxa se li assignarà automàticament una adreça amb el format que s’ha descrit en seccions anteriors.</p>
<p>En la Fig. <a href="#fig:testdex" data-reference-type="ref" data-reference="fig:testdex">26</a> es mostren les propietats i mètodes del contracte intel·ligent que emprarem (anomenat “TestDEX”). Cal dir, que en argot específic de <em>blockchain</em> seria més apropiat anomenar a una propietat “emmagatzematge”.</p>
<figure>
<img src="TestDEX.png" id="fig:testdex" style="width:55.0%" alt="" /><figcaption>Estructura del contracte intel·ligent.</figcaption>
</figure>
<p>La descripció dels “emmagatzematges” és la següent:</p>
<ul>
<li><p><strong>liquidity_token(TokenIdentifier)</strong>: Emmagatzema la liquiditat dels <em>tokens</em> (la meitat del parell). Per als identificadors del token de què vulguem guardar la informació, tindrem un valor del tipus BigUint<a href="#fn47" class="footnote-ref" id="fnref47" role="doc-noteref"><sup>47</sup></a> associat que definirà la seva quantitat acumulada en el contracte intel·ligent. Disposa d’un <em>getter</em> <strong>getLiquidityToken</strong> (amb el mateix paràmetre).</p></li>
<li><p><strong>liquidity_egld(TokenIdentifier)</strong>: Guarda la liquiditat en EGLD dels <em>tokens</em> (l’altra part del parell). Per als identificadors dels tokens dels que vulguem guardar la informació, tindrem un valor del tipus BigUint associat que definirà la quantitat d’EGLD. Disposa d’un <em>getter</em> <strong>getLiquidityEgld</strong> (amb el mateix paràmetre).</p></li>
<li><p><strong>initial_k(TokenIdentifier)</strong>: Per a cada parell <em>token</em>-EGLD emmagatzema un BigUint amb la seva constant <span class="math inline"><em>k</em></span> del moment en què es va donar d’alta. Disposa d’un <em>getter</em> <strong>getInitialK</strong> (amb el mateix paràmetre).</p></li>
<li><p><strong>fee</strong>: Guarda la taxa –amb un valor del tipus u32<a href="#fn48" class="footnote-ref" id="fnref48" role="doc-noteref"><sup>48</sup></a>– que s’aplicarà quan es faci un intercanvi. S’inicialitza quan es creï el contracte intel·ligent. Disposa d’un <em>getter</em> <strong>getFee</strong>.</p></li>
<li><p><strong>earnings_egld(TokenIdentifier)</strong>: Emmagatzema les taxes (<em>fees</em>) –BigUint– cobrades pels diferents <em>tokens</em>. Disposa d’un <em>getter</em> <strong>getEarnings</strong> (amb el mateix paràmetre).</p></li>
</ul>
<p>Pel que fa als mètodes:</p>
<ul>
<li><p><strong>init(u32)</strong>: Mètode que realitza la tasca de constructor del contracte intel·ligent. Se li passa la taxa que es cobrarà en els intercanvis.</p></li>
<li><p><strong>addLiquidityToken() -&gt;SCResult</strong>: Afegeix liquiditat a la part “<em>token</em>” del parell. Retorna un valor del tipus SCResult, forma predeterminada de retornar opcionalment un error (<span class="math inline"><em>E</em><em>r</em><em>r</em>(<em>S</em><em>C</em><em>E</em><em>r</em><em>r</em><em>o</em><em>r</em>)</span>) o una confirmació de resultat satisfactori (<span class="math inline"><em>O</em><em>k</em>(<em>T</em>)</span>). El token i la quantitat les agafarà de la mateixa transacció dins de la xarxa Elrond. Mètode que només pot ser cridat pel propietari del contracte.</p></li>
<li><p><strong>claimLiquidityToken(TokenIdentifier) -&gt;SCResult</strong>: Envia els fons de liquiditat d’un <em>token</em> determinat aportats pel propietari del contracte intel·ligent a l’adreça del seu moneder. Se li ha de passar com a paràmetre l’identificador del <em>token</em> de què volem reclamar la liquiditat. Mètode que només pot ser cridat pel propietari del contracte. Retorna un BigUint equivalent a la quantitat transferida. Només es torna la part “token”. El parell quedarà en estat “Funding”.</p></li>
<li><p><strong>addLiquidityEgld(TokenIdentifier) -&gt;SCResult</strong>: Afegeix liquiditat a la part EGLD del parell. Se li ha de passar com a paràmetre l’identificador d’EGLD. La quantitat l’agafarà de la mateixa transacció dins de la xarxa Elrond. Mètode que només pot ser cridat pel propietari del contracte.</p></li>
<li><p><strong>claimLiquidityEgld(TokenIdentifier) -&gt;SCResult</strong>: Envia els fons de liquiditat en EGLD del parell d’un determinat <em>token</em> aportats pel propietari del contracte intel·ligent a l’adreça del seu moneder. Se li ha de passar com a paràmetre l’identificador del <em>token</em> de què volem guardar la informació. Mètode que només pot ser cridat pel propietari del contracte. Retorna un BigUint equivalent a la quantitat transferida. El parell quedarà en estat “Funding”.</p></li>
<li><p><strong>status(TokenIdentifier) -&gt;Status</strong>: Mostra l’estat d’un parell. Tindrà dos possibles estats: “Successful” i “Funding”. El primer significa que està preparat per fer intercanvis i el segon indica que encara s’han d’afegir fons a algun dels components del parell. Se li ha de passar com a paràmetre l’identificador del <em>token</em> de què volem retornar aquesta informació. Retorna o bé “Successful” o bé “Funding”.</p></li>
<li><p><strong>calculateK(TokenIdentifier) -&gt;BigUint</strong>: Calcula la constant <span class="math inline"><em>k</em></span> per a un parell en un moment donat de temps. Se li ha de passar com a paràmetre l’identificador del <em>token</em> que identifica el parell de què volem retornar aquesta informació (el que no sigui EGLD). Retorna la citada constant.</p></li>
<li><p><strong>claimEarnings(TokenIdentifier) -&gt;BigUint</strong>: Envia els beneficis acumulats resultants d’aplicar la taxa als intercanvis d’un <em>token</em> determinat al contracte. Se li ha de passar com a paràmetre l’identificador del <em>token</em> de què volem transferir els beneficis. Mètode que només pot ser cridat pel propietari del contracte. Retorna un BigUint equivalent a la quantitat transferida.</p></li>
<li><p><strong>priceEgldToken(TokenIdentifier, BigUint) -&gt;BigUint</strong>: Calcula el preu d’una certa quantitat d’un <em>token</em> determinat en EGLD aplicant la taxa (<em>fee</em>). Se li ha de passar com a arguments l’identificador del <em>token</em> de què volen calcular el preu i la citada quantitat. Retorna el preu com a nombre enter.</p></li>
<li><p><strong>priceEgldTokenNoFee(TokenIdentifier, BigUint)-&gt;BigUint</strong>: És igual que l’anterior però al preu retornat no se li aplica la taxa.</p></li>
<li><p><strong>feeEgldToken(TokenIdentifier, BigUint) -&gt;BigUint</strong>: Calcula la taxa que es pagarà per una certa quantitat d’un <em>token</em> en EGLD. Se li han de passar com a arguments l’identificador del <em>token</em> de què volen calcular el preu i la citada quantitat. Retorna aquest cost com a nombre enter.</p></li>
<li><p><strong>priceTokenEgld(TokenIdentifier, BigUint) -&gt;BigUint</strong>: Calcula el preu d’una certa quantitat d’EGLD en un <em>token</em> determinat. Se li han de passar com a arguments l’identificador del <em>token</em> amb què volem pagar i la quantitat d’EGLD que volem obtenir. Retorna el preu com a nombre enter. S’aplica la taxa (<em>fee</em>).</p></li>
<li><p><strong>priceTokenEgldNoFee(TokenIdentifier, BigUint) -&gt;BigUint</strong>: Igual que l’anterior però al preu retornat no se li aplica la taxa.</p></li>
<li><p><strong>feeTokenEgld(TokenIdentifier, BigUint) -&gt;BigUint</strong>: Calcula la taxa que es pagarà per una certa quantitat d’EGLD en un <em>token</em> determinat. Se li han de passar com a arguments l’identificador del <em>token</em> i la citada quantitat. Retorna aquest cost com a nombre enter.</p></li>
<li><p><strong>swapEgldForToken(TokenIdentifier) -&gt;SCResult</strong>: Per intercanviar <em>tokens</em> per EGLD. La quantitat d’EGLD s’agafarà de la transacció. S’enviarà la quantitat del <em>token</em> al moneder de l’usuari que faci la compra. Les taxes pagades s’acumularan al contracte intel·ligent. S’haurà de passar com a argument l’identificador del <em>token</em> que es vol comprar. Les taxes es llevaran de la quantitat que ha de rebre l’usuari com a resultat de l’intercanvi.</p></li>
<li><p><strong>swapTokenForEgld(TokenIdentifier) -&gt;SCResult</strong>: El sentit invers de l’anterior, comprar EGLD amb <em>token</em>. El <em>token</em> i la quantitat d’EGLD s’agafaran de la transacció. S’enviarà la quantitat d’EGLD al moneder de l’usuari que faci la compra. Les taxes pagades s’acumularan al contracte intel·ligent (es llevaran de la quantitat que ha de rebre l’usuari com a resultat de l’intercanvi).</p></li>
</ul>
<p>Com ja s’ha dit, Elrond VM es basa en WebAssembly (WASM). A l’especificació <strong>se li ha llevat el suport a les operacions de coma flotant</strong> <span class="citation" data-cites="mincub2020"></span>. Això ha provocat que s’hagin d’haver adaptat les fórmules desenvolupades en la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>. D’aquesta forma, per a certs mètodes del contracte intel·ligent en generaran dos de nous: un mètode que retorni el numerador i un altre que retorni el denominador. La idea de fer aquesta separació és fer les operacions de divisió a la DApp (que sí que permet operar amb decimals). Això té certa importància a nivell visual per a l’usuari, ja que és més comprensible llegir “1.21 xEGLD” que no pas “1210000000000000000 wei”. A part d’això, es generava també el problema de què la taxa (<em>fee</em>) no podia ser un nombre decimal. Això ha implicat que, a part de separar en numerador i denominador, es transformin les citades equacions de la següent forma perquè aquesta comissió sigui un nombre enter:<a href="#fn49" class="footnote-ref" id="fnref49" role="doc-noteref"><sup>49</sup></a> <br /><span class="math display">$$t'_x = \frac{x * t_y *(1000 - fee)}{1000 * y + t_y * (1000 - fee)}$$</span><br /> <br /><span class="math display"><em>t</em>′<sub><em>x</em><sub><em>n</em><em>u</em><em>m</em><em>e</em><em>r</em><em>a</em><em>d</em><em>o</em><em>r</em></sub></sub> = <em>x</em> * <em>t</em><sub><em>y</em></sub> * (1000 − <em>f</em><em>e</em><em>e</em>)</span><br /> <br /><span class="math display"><em>t</em>′<sub><em>x</em><sub><em>d</em><em>e</em><em>n</em><em>o</em><em>m</em><em>i</em><em>n</em><em>a</em><em>d</em><em>o</em><em>r</em></sub></sub> = 1000 * <em>y</em> + <em>t</em><sub><em>y</em></sub> * (1000 − <em>f</em><em>e</em><em>e</em>)</span><br /> <br /><span class="math display">$$t'_y = \frac{y * t_x * (1000 - fee)}{1000 * x + t_x * (1000 - fee)}$$</span><br /> <br /><span class="math display"><em>t</em>′<sub><em>y</em><sub><em>n</em><em>u</em><em>m</em><em>e</em><em>r</em><em>a</em><em>d</em><em>o</em><em>r</em></sub></sub> = <em>y</em> * <em>t</em><sub><em>x</em></sub> * (1000 − <em>f</em><em>e</em><em>e</em>)</span><br /> <br /><span class="math display"><em>t</em>′<sub><em>y</em><sub><em>d</em><em>e</em><em>n</em><em>o</em><em>m</em><em>i</em><em>n</em><em>a</em><em>d</em><em>o</em><em>r</em></sub></sub> = 1000 * <em>x</em> + <em>t</em><sub><em>x</em></sub> * (1000 − <em>f</em><em>e</em><em>e</em>)</span><br /> Amb aquests canvis, <em>fee</em> podrà ser un nombre enter. Com ja hem vist, un valor de 5 aplicarà una taxa del 0,5%.</p>
<p>En resum, per separar el numerador i el denominador i aplicant el citat canvi perquè la taxa sigui un nombre enter, s’han hagut d’afegir al contracte intel·ligent:</p>
<ul>
<li><p>Pel mètode priceEgldTokenNumerator apareixen els nous:</p>
<ul>
<li><p>priceEgldTokenNumerator</p></li>
<li><p>priceEgldTokenDenominator</p></li>
</ul></li>
<li><p>Pel mètode priceEgldTokenNoFee apareixen els nous:</p>
<ul>
<li><p>priceEgldTokenNoFeeNumerator</p></li>
<li><p>priceEgldTokenNoFeeDenominator</p></li>
</ul></li>
<li><p>Pel mètode priceTokenEgld apareixen els nous:</p>
<ul>
<li><p>priceTokenEgldNumerator</p></li>
<li><p>priceTokenEgldDenominator</p></li>
</ul></li>
<li><p>I, finalment, del mètode priceTokenEgldNoFee apareixen els nous:</p>
<ul>
<li><p>priceTokenEgldNoFeeNumerator</p></li>
<li><p>priceTokenEgldNoFeeDenominator</p></li>
</ul></li>
</ul>
<h3 id="subsub:arq">Arquitectura</h3>
<p>Una <strong>DApp</strong> ens permetrà escriure en la blockchain i llegir l’emmagatzematge –o estat– del contracte intel·ligent descrit en l’apartat anterior. Com es pot comprovar en la Fig. <a href="#fig:architecture" data-reference-type="ref" data-reference="fig:architecture">27</a>, <strong>per escriure en la cadena de blocs</strong> la DApp haurà de llençar una <strong>transacció</strong> que invoqui a un mètode del contracte. Si per contra només necessitem <strong>llegir l’estat</strong> del contracte intel·ligent, emprarem una <strong>API</strong> aportada per Elrond per invocar certs mètodes del contracte, cosa que no farà pas cap canvi en la cadena de blocs.</p>
<figure>
<img src="architecture.png" id="fig:architecture" style="width:75.0%" alt="" /><figcaption>Arquitectura de testDEX. (Font: Elaboració pròpia inspirada en <span class="citation" data-cites="elrond2022"></span>).</figcaption>
</figure>
<p>Pot parèixer una descripció molt breu, però és que és veritablement una arquitectura molt senzilla.</p>
<h3 id="pantalles">Pantalles</h3>
<p>Per <strong>accedir a la DApp</strong> s’haurà de triar un dels mètodes habilitats per fer-ho a la xarxa Elrond (Fig. <a href="#fig:screenlogin" data-reference-type="ref" data-reference="fig:screenlogin">28</a>).</p>
<figure>
<img src="screen_login.png" id="fig:screenlogin" alt="" /><figcaption>Finestra de login.</figcaption>
</figure>
<figure>
<img src="screen_claim.png" id="fig:screenclaim" alt="" /><figcaption>Finestra on reclamar els fons i els beneficis.</figcaption>
</figure>
<p>Només per a l’<strong>usuari que sigui el propietari del contracte</strong>, li apareixerà en el menú d’adalt a la dreta les <strong>opcions “Claim” i “Fund”</strong>. En la pantalla “Fund” es podran <strong>crear els diferents fons de liquiditat del contracte intel·ligent</strong> (Fig. <a href="#fig:screenfund" data-reference-type="ref" data-reference="fig:screenfund">30</a>) i en la finestra “Claim” es podran reclamar els fons i els beneficis obtinguts (Fig. <a href="#fig:screenclaim" data-reference-type="ref" data-reference="fig:screenclaim">29</a>). S’ha de destacar que els fons una vegada creats, ja no es poden modificar a no ser que es realitzin <em>swaps</em> en la finestra de “Trade”. També es poden reclamar a la finestra “Claim” i a partir d’aquí es poden tonar a crear.</p>
<figure>
<img src="screen_fund.png" id="fig:screenfund" alt="" /><figcaption>Finestra on s’aprovisionen els <em>liquidity pools</em>.</figcaption>
</figure>
<figure>
<img src="screen_trade.png" id="fig:screentrade" alt="" /><figcaption>Finestra on es poden realitzar els <em>swaps</em>.</figcaption>
</figure>
<p>En l’<strong>opció del menú “Trade”</strong> trobem la finestra amb el cor de l’aplicació (Fig. <a href="#fig:screentrade" data-reference-type="ref" data-reference="fig:screentrade">33</a>). Es podran <strong>seleccionar els parells dels quals s’han donat d’alta fons de liquiditat i realitzar compres o vendes</strong>. Es mostraran les dades referents a les operacions que es faran (quantitat de <em>tokens</em> que rebrem si els comprem amb xEGLD prement el botó “<em>Buy</em>” o quantitat de xEGLD que rebrem si venem el citat <em>token</em> prement el botó “<em>Sell</em>”). També apareixeran les quantitats disponibles del parell dins del <em>pool</em> i dins de la <em>wallet</em> de l’usuari. Abaix a la dreta es pot observar que es veurà l’estat de la constant <span class="math inline"><em>k</em></span> en el moment actual (“<em>Current k</em>”) i quan es va inicialitzar el fons (“<em>Initial k</em>”)</p>
<h2 id="sec:imp">Implementació</h2>
<h3 id="repositoris-disponibles">Repositoris disponibles</h3>
<p>He dividit el projecte en quatre repositoris a Github:</p>
<ul>
<li><p><strong>TFM_latex</strong><a href="#fn50" class="footnote-ref" id="fnref50" role="doc-noteref"><sup>50</sup></a>: El present document amb tots els recursos necessaris per generar-lo.</p></li>
<li><p><strong>TFM_smart_contract</strong><a href="#fn51" class="footnote-ref" id="fnref51" role="doc-noteref"><sup>51</sup></a>: Contracte intel·ligent del projecte escrit en Rust (es pot consultar en l’arxiu “testdex.rs”). Es troben també altres recursos necessaris per compilar-lo, així com d’altres per fer-ne proves.</p></li>
<li><p><strong>TFM_DApp</strong><a href="#fn52" class="footnote-ref" id="fnref52" role="doc-noteref"><sup>52</sup></a>: Aquí es troba la DApp que interacciona amb el contracte intel·ligent del punt anterior. Es basa en la plantilla “DApp-template” aportada per Elrond<a href="#fn53" class="footnote-ref" id="fnref53" role="doc-noteref"><sup>53</sup></a>.</p></li>
<li><p><strong>TFM_stats</strong><a href="#fn54" class="footnote-ref" id="fnref54" role="doc-noteref"><sup>54</sup></a>: Es tracta d’un <em>script</em> escrit en Python per comprovar el rendiment de la xarxa d’Elrond. Es llançaran peticions emprant <em>erdpy</em> al contracte intel·ligent descrit.</p></li>
</ul>
<h3 id="imp:aspectes">Aspectes a destacar de la implementació</h3>
<p>En primer lloc, vull destacar les diferents formes en què s’ha interactuat des de la DApp amb la <em>blockchain</em>:</p>
<ul>
<li><p><strong>Transferències ESDT</strong>: Són transaccions signades. Tenen la característica de què el valor de la transacció (camp “<span class="math inline"><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></span>”) serà de 0 xEGLD. El token, la quantitat del mateix, el mètode que es trucarà del <em>smart contract</em> i els respectius paràmetres aniran dins del camp “<span class="math inline"><em>d</em><em>a</em><em>t</em><em>a</em></span>” (al principi d’aquest camp s’indicarà que és aquest tipus de transferència amb el text “<span class="math inline"><em>E</em><em>S</em><em>D</em><em>T</em><em>T</em><em>r</em><em>a</em><em>n</em><em>s</em><em>f</em><em>e</em><em>r</em></span>”). Es pot observar en la Fig. <a href="#fig:impesdttransfer" data-reference-type="ref" data-reference="fig:impesdttransfer">32</a>.</p></li>
<li><p><strong>Transferències de xEGLD</strong>: També són transaccions signades. En el camp “<span class="math inline"><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></span>” anirà el valor de la transacció expressat en “wei” d’EGLD. En el camp “<span class="math inline"><em>d</em><em>a</em><em>t</em><em>a</em></span>” es posarà el mètode que es trucarà del <em>smart contract</em> i els respectius paràmetres.</p></li>
<li><p><strong><em>Queries</em> al smart <em>contract</em></strong>: No duen associada una transacció signada. Es demana l’execució d’un mètode del contracte intel·ligent que no duu associat cap transferència d’actius, simplement consulta l’estat d’aquest. En la Fig. <a href="#fig:imp-queryapirest" data-reference-type="ref" data-reference="fig:imp-queryapirest">34</a> es pot observar un exemple.</p></li>
<li><p><strong>Consulta a l’API REST de la devnet d’Elrond</strong><a href="#fn55" class="footnote-ref" id="fnref55" role="doc-noteref"><sup>55</sup></a>: S’ha comentat de passada la seva existència a la secció <a href="#sub:altres" data-reference-type="ref" data-reference="sub:altres">2.13</a>. Permet consultar dades sobre l’estat dels diferents elements de la devnet d’Elrond (òbviament, existeixen les respectives versions per a les altres xarxes). La seva utilitat m’ha semblat determinant. Per exemple, l’empro per consultar els actius del moneder d’un client o els actius disponibles en el contracte intel·ligent. Un exemple d’ús es pot consultar en la Fig. <a href="#fig:imp-queryapirest" data-reference-type="ref" data-reference="fig:imp-queryapirest">34</a>.</p></li>
</ul>
<figure>
<img src="imp-esdttransfer.png" id="fig:impesdttransfer" alt="" /><figcaption>Exemple de transferència ESDT.</figcaption>
</figure>
<figure>
<img src="imp-egldtransfer.png" id="fig:screentrade" alt="" /><figcaption>Exemple de transferència xEGLD.</figcaption>
</figure>
<figure>
<img src="imp-mytransactions.png" style="width:65.0%" alt="" /><figcaption>Funció emprada en les transferències de la Fig. <a href="#fig:tipustransfer" data-reference-type="ref" data-reference="fig:tipustransfer">[fig:tipustransfer]</a>.</figcaption>
</figure>
<figure>
<img src="imp-queryapirest.png" id="fig:imp-queryapirest" style="width:65.0%" alt="" /><figcaption>Consultes a l’API REST de la devnet d’Elrond.</figcaption>
</figure>
<h3 id="correcció-de-la-constant-k-per-lerror-introduït-per-larrodoniment"><em>Correcció de la constant <span class="math inline"><em>k</em></span> per l’error introduït per l’arrodoniment</em></h3>
<p>Com s’ha comentat en la part de disseny, a la màquina virtual d’Elrond se li ha llevat el suport a les operacions de coma flotant. Com s’ha dit també, això provocarà que es vagi acumulant un error en la constant <span class="math inline"><em>k</em></span> que podria desvirtuar la natura del protocol AMM. Així com està implementat el <em>smart contract</em>, aquest error es va acumulant en el fons del contracte intel·ligent. Òbviament, és un error lleu que farà que el propietari del <em>pool</em> tingui més benefici. Mostra d’aquest error que es va acumulant es pot veure en la Fig. <a href="#fig:imperrork" data-reference-type="ref" data-reference="fig:imperrork">35</a>. Animo al lector que revisi la referència bibliogràfica <span class="citation" data-cites="zhang2018"></span>.</p>
<figure>
<img src="imp-errork.png" id="fig:imperrork" style="width:75.0%" alt="" /><figcaption>Error acumulat en la constant <span class="math inline"><em>k</em></span>.</figcaption>
</figure>
<p>He dedicat temps a intentar solucionar el problema i he arribat a diverses solucions on la <span class="math inline"><em>k</em></span> es va ajustant quan passa per sota o per sobre del valor original. El problema d’aquestes solucions és que no les he pogut demostrar matemàticament (cosa no apropiada per a un treball acadèmic). En la Fig. <a href="#fig:impcorrectk" data-reference-type="ref" data-reference="fig:impcorrectk">[fig:impcorrectk]</a> es pot veure comentat un exemple d’aquestes proves (n’hi ha més al repositori de Github corresponent).</p>
<figure>
<img src="imp-sc01.png" id="fig:impsc01" alt="" /><figcaption>Mètode “swapTokenForEgld”.</figcaption>
</figure>
<figure>
<img src="imp-sc02.png" id="fig:impsc02" alt="" /><figcaption>Mètode “swapEgldForToken”.</figcaption>
</figure>
<h2 id="posada-en-producció">Posada en producció</h2>
<h3 id="desplegament-del-contracte-intelligent">Desplegament del contracte intel·ligent</h3>
<p>Començarem compilant el <em>smart contract</em>. Executarem dins el directori on es trobi el codi font del contracte intel·ligent:<a href="#fn56" class="footnote-ref" id="fnref56" role="doc-noteref"><sup>56</sup></a>.</p>
<pre><code>[
    basicstyle=\footnotesize,
]
erdpy contract build</code></pre>
<p>Amb això generarem el fitxer “testdex.wasm” que desplegarem a la <em>devnet</em> d’Elrond amb la comanda:</p>
<pre><code>[
    basicstyle=\footnotesize,
]
erdpy contract deploy --pem=&quot;~/wallet/wallet3.pem&quot; \
  --recall-nonce --gas-limit=100000000 --project=. \
  --proxy=&quot;https://devnet-gateway.elrond.com&quot; \
  --chain=&quot;D&quot; --arguments 0x05 --send</code></pre>
<p>D’entre els paràmetres, s’ha de destacar que dins de “<span>/wallet/wallet3.pem</span>” es troba la clau privada de l’usuari de la devnet d’Elrond que desplegarà el contracte intel·ligent a la xarxa (que serà el propietari) i amb “--arguments 0x05” li passem en hexadecimal l’argument necessari per al mètode que fa de constructor (un valor de 5 implica una comissió del 0.5%). Aquesta comanda mostrarà per la consola, entre altres coses, l’adreça del contracte intel·ligent dins de la <em>devnet</em> d’Elrond. En el nostre cas:</p>
<pre><code>[
    basicstyle=\footnotesize,
]
erd1qqqqqqqqqqqqqpgq578zh88hskf9efwzyhkf64el7d6ve3lrsn2qwkvmt2</code></pre>
<h3 id="desplegament-de-la-dapp">Desplegament de la DApp</h3>
<p>He donat d’alta dins del servei <a href="noip.com">noip.com</a> el nom testdex.ddns.net perquè apunti a un VPS (<em>Virtual Private Server</em>) a OVH<a href="#fn57" class="footnote-ref" id="fnref57" role="doc-noteref"><sup>57</sup></a>. Al servidor he clonat el repositori amb l’ordre:</p>
<pre><code>[
    basicstyle=\footnotesize,
]
git clone git@github.com:sergiogrubio/TFM_DApp.git</code></pre>
<p>Dins del directori clonat he executat:</p>
<pre><code>[
    basicstyle=\footnotesize,
]
npm run build
serve -s build</code></pre>
<p>Després he fet una redirecció de ports amb:</p>
<pre><code>[
    basicstyle=\footnotesize,
]
# localhost/loopback
sudo iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 80 \
    -j REDIRECT --to-ports 3000

# external
sudo iptables -t nat -I PREROUTING -p tcp --dport 80 -j REDIRECT \
    --to-ports 3000</code></pre>
<p>La DApp estarà disponible durant el temps d’avaluació d’aquest TFM a l’URL: <a href="http://testdex.ddns.net/">http://testdex.ddns.net/</a>. La única intenció és facilitar la revisió del treball (i no haver de clonar el repositori i executar-lo en local).</p>
<h2 id="proves">Proves</h2>
<h3 id="subsub:sc">Sobre el contracte intel·ligent</h3>
<p>Les proves sobre el contracte intel·ligent tenen una especial importància, ja que errades en el seu disseny i/o implementació poden provocar pèrdues econòmiques. Per testejar el contracte intel·ligent el primer que he fet és definir <strong>“interaccions” mitjançant <em>snippets</em></strong> que empren l’eina <em>erdpy</em>. En gerga d’Elrond, això seria “crear un fitxer d’interaccions” (en aquest cas anomenat “devnet.snippets.sh”). Després fent clic amb el botó dret al <em>plugin</em><a href="#fn58" class="footnote-ref" id="fnref58" role="doc-noteref"><sup>58</sup></a> d’Elrond a Visual Studio Code podrem accedir als <em>snippets</em> (Fig. <a href="#fig:test-snippets" data-reference-type="ref" data-reference="fig:test-snippets">38</a>).</p>
<figure>
<img src="test-snippets.png" id="fig:test-snippets" style="width:100.0%" alt="" /><figcaption><em>Snippets</em> en l’IDE Visual Studio Code.</figcaption>
</figure>
<p>Hi ha definit un <em>snippet</em> per a cada mètode del contracte intel·ligent, a més de dos addicionals per compilar-lo i desplegar-lo a la xarxa d’Elrond. Ja s’han comentat anteriorment els mètodes del contracte intel·ligent i els respectius <em>snippets</em> permeten executar-los (i així comprovar si el comportament és l’esperat). Vull parar l’atenció en els que penso que són il·lustratius del funcionament d’<em>erdpy</em>:</p>
<ul>
<li><p><strong>Trucades a mètodes del contracte intel·ligent que impliquen transferència d’actius</strong> (<em>erdpy contract call</em>):</p>
<ul>
<li><p><strong>Transferència d’EGLD del client cap al contracte</strong> (<em>snippet</em> “addLiquidityEgld”): En la Fig. <a href="#fig:test-addegld" data-reference-type="ref" data-reference="fig:test-addegld">43</a> es pot veure un exemple de com transferir EGLD al contracte intel·ligent. S’ha de destacar que l’opció “--value” inclourà la quantitat d’EGLD a traspassar en wei i l’opció “--function” especificarà el mètode del contracte amb la lògica que tractarà el citat moviment (els arguments que se li passen es definiran en “--arguments” i estaran codificats en hexadecimal). Dins el mètode del contracte intel·ligent es podrà recuperar la quantitat d’EGLD amb:</p>
<pre><code>let payment = self.call\_value().egld\_value();</code></pre></li>
<li><p><strong>Transferència de tokens ESDT del client cap al contracte</strong> (<em>snippet</em> “addLiquidityToken”): Aquest cas és un exemple de com transferir tokens ESDT (Fig. <a href="#fig:test-addtoken" data-reference-type="ref" data-reference="fig:test-addtoken">44</a>). Aquí no s’especificarà opció “--value” i en l’opció “--function” es posarà el text “ESDTTransfer”. En l’opció arguments –codificat en hexadecimal– es passarà el nom del token, la quantitat del mateix i el nom del mètode del contracte amb la lògica per gestionar la trucada. Ja dins el mètode del contracte intel·ligent, el token i la quantitat es podran recuperar amb:</p>
<pre><code>let (payment, token) =
    self.call_value().payment_token_pair();</code></pre></li>
<li><p><strong>Transferència d’EGLD/token del contracte cap al client</strong> (<em>snippet</em> “claimLiquidityToken”): Aquí es cridarà un mètode que generarà una transferència –tant d’EGLD com de tokens ESDT– cap a algun <em>wallet</em> (Fig. <a href="#fig:test-liquiditytoken" data-reference-type="ref" data-reference="fig:test-liquiditytoken">41</a>). L’opció “--value” s’especificarà amb valor 0 i en l’opció “--function” es posarà el mètode del contracte amb la lògica que tractarà el citat moviment (els arguments que se li passen es definiran en “--arguments” i estaran codificats en hexadecimal).</p></li>
</ul></li>
<li><p><strong>Trucades a mètodes del contracte intel·ligent sense transferència d’actius</strong> (<em>erdpy contract query</em>): En la Fig. <a href="#fig:test-getearnings" data-reference-type="ref" data-reference="fig:test-getearnings">42</a> es pot veure aquest cas. Serà suficient amb especificar el mètode que es crida i els arguments codificats en hexadecimal. Com que no es tracta d’una transacció que modifiqui la <em>blokchain</em>, és molt més ràpida.</p></li>
</ul>
<figure>
<img src="test-addegld.png" id="fig:test-addegldsnip" alt="" /><figcaption>“addLiquidityEgld”.</figcaption>
</figure>
<figure>
<img src="test-addtoken.png" id="fig:test-addtokensnip" alt="" /><figcaption>“addLiquidityToken”.</figcaption>
</figure>
<figure>
<img src="test-liquiditytoken.png" id="fig:test-liquiditytoken" alt="" /><figcaption>“claimLiquidityToken”.</figcaption>
</figure>
<figure>
<img src="test-getearnings.png" id="fig:test-getearnings" alt="" /><figcaption>“claimEarningsToken”.</figcaption>
</figure>
<p>S’han executat els següents <strong><em>snippets</em></strong> per validar el contracte intel·ligent<a href="#fn59" class="footnote-ref" id="fnref59" role="doc-noteref"><sup>59</sup></a>:</p>
<ul>
<li><p><strong>Compilar el contracte intel·ligent</strong>: <em>Snippet</em> “build”.</p></li>
<li><p><strong>Desplegar el contracte intel·ligent</strong>: <em>Snippet</em> “deploy”. Com a paràmetre si li passa la taxa (<em>fee</em>) que es cobrarà en els <em>swaps</em>.</p></li>
<li><p><strong>Comprovar que el contracte s’ha desplegat correctament</strong>: <em>Snippet</em> “checkDeployment”.</p></li>
<li><p><strong>Afegir un fons de liquiditat</strong>: <em>Snippets</em> “addLiquidityToken” (Fig. <a href="#fig:test-addegld" data-reference-type="ref" data-reference="fig:test-addegld">43</a>) i “addLiquidityEgld” (Fig. <a href="#fig:test-addtoken" data-reference-type="ref" data-reference="fig:test-addtoken">44</a>). Es torna a afegir fons al parell per comprovar que no deixa. Finalment, s’intenta crear un fons des d’una cartera que no és la propietaria del contracte intel·ligent per comprovar que dona error (dins del fitxer <em>devenet.snippets.sh</em> s’ha de canviar la constant <em>OWNER_PEM=“./wallet/wallet1.pem”</em> per <em>OWNER_PEM=“./wallet/wallet2.pem”</em>).</p></li>
<li><p><strong>Obtenir la liquiditat del <em>pool</em></strong>: <em>Snippets</em> “getLiquidityToken” i “getLiquidityEgld”. Òbviament, els valors obtinguts hauran de coincidir amb les quantitats que s’han d’especificar en la creació del fons en el punt anterior.</p></li>
<li><p><strong>Obtenir l’estat del fons de liquiditat</strong>: <em>Snippet</em> “getLiquidityStatus”. Executat abans de constituir el fons i després de constituir-lo (ha de donar valors diferents).</p></li>
<li><p><strong>Calcular la constant K actual</strong>: <em>Snippets</em> “calculateK” i “getRatio”. Per l’error de rendodeig en la divisió entre nombres enters que s’ha comentat abans, anirà fluctuant un poc per sobre i per sota del valor de la constant del moment de constituir el fons. S’ha comprovat fent <em>swaps</em> que és així.</p></li>
<li><p><strong>Comprovar que la taxa (<em>fee</em>)</strong>: <em>Snippet</em> “getFee”. La taxa ha de ser la mateixa que es va definir en el moment de desplegar el contracte intel·ligent.</p></li>
<li><p><strong>Calcular el preu en token de l’EGLD (amb i sense taxa)</strong>: <em>Snippets</em> “getPriceEgldToken”, “getPriceEgldTokenNumerator”, “getPriceEgldTokenDenominator”, “getPriceEgldTokenNoFee” i “getFeeEgldToken”<a href="#fn60" class="footnote-ref" id="fnref60" role="doc-noteref"><sup>60</sup></a>. S’ha comprovat que es generen els mateixos preus que en l’exemple descrit en la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>.</p></li>
<li><p><strong>Calcular el preu en EGLD del token (amb i sense taxa)</strong>: <em>Snippets</em> “getPriceTokenEgld”, “getPriceTokenEgldNumerator”, “getPriceTokenEgldDenominator”, “getPriceTokenEgldNoFee” i “getFeeTokenEgld”<a href="#fn61" class="footnote-ref" id="fnref61" role="doc-noteref"><sup>61</sup></a>. S’ha comprovat que es generen els mateixos preus que en l’exemple descrit en la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>.</p></li>
<li><p><strong>Comprovar els beneficis obtinguts pels swaps realitzats</strong>: <em>Snippets</em> “getEarningsEgld” i “getEarningsToken”. També s’han comprovat que complien amb l’estudi teòric fet a la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>.</p></li>
<li><p><strong>Comprovar que el propietari del contracte rep els beneficis d’un token concret quan els reclama</strong>: <em>Snippet</em> “claimEarningsToken()”. S’ha d’emprar també el <em>snippet</em> “getEarningsToken” per esbrinar la quantitat a rebre i després d’executar-lo ha d’aparèixer a la cartera del propietari del <em>smart contract</em>.</p></li>
<li><p><strong>Comprovar que el propietari del contracte rep els beneficis en EGLD quan els reclama</strong>: <span>Snippet</span> “claimEarningsEgld()”. S’ha d’emprar també el <em>snippet</em> “getEarningsEgld” per esbrinar la quantitat a rebre i després d’executar-lo ha d’aparèixer a la cartera del propietari del <em>smart contract</em>. Per disseny, l’EGLD que es recuperarà serà el generat amb tots els <em>swaps</em> (independentment del parell).</p></li>
<li><p><strong>Comprovar que el propietari del contracte rep la part d’EGLD d’un fons de liquiditat quan la reclama</strong>: <span>Snippet</span> “claimLiquidityEgld()”. S’ha d’emprar també el <em>snippet</em> “getLiquidityEgld” per esbrinar la quantitat a rebre i després d’executar-lo ha d’aparèixer a la cartera del propietari del <em>smart contract</em>. A diferència del que passa amb “claimEarningsEgld()”, aquí només es rebrà l’EGLD d’un parell en concret.</p></li>
<li><p><strong>Comprovar que el propietari del contracte rep la part del token d’un fons de liquiditat quan la reclama</strong>: <span>Snippet</span> “claimLiquidityToken()”. S’ha d’emprar també el <em>snippet</em> “getLiquidityToken” per esbrinar la quantitat a rebre i després d’executar-lo ha d’aparèixer a la cartera del propietari del <em>smart contract</em>.</p></li>
<li><p><strong>Comprovar que es poden intercanviar EGLD per token</strong>: <em>Snippet</em> “swapEgldForToken()”. S’ha comprovat que es generen els mateixos resultats que els descrits en l’exemple de la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>. Així mateix, s’emprarà el <em>snippet</em> “getPriceEgldToken” per conèixer la quantitat de token que hem de rebre a la cartera.</p></li>
<li><p><strong>Comprovar que es poden intercanviar token per EGLD</strong>: <em>Snippet</em> “swapTokenForEgld()”. S’ha comprovat que es generen els mateixos resultats que els descrits en l’exemple de la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>. Així mateix, s’emprarà el <em>snippet</em> “getPriceTokenEgld” per conèixer la quantitat d’EGLD que hem de rebre a la cartera.</p></li>
</ul>
<figure>
<img src="testsnipped-addegld.png" id="fig:test-addegld" alt="" /><figcaption>“addLiquidityEgld”.</figcaption>
</figure>
<figure>
<img src="testsnipped-addtoken.png" id="fig:test-addtoken" alt="" /><figcaption>“addLiquidityToken”.</figcaption>
</figure>
<p>Finalment, Elrond disposa d’una eina anomenada <strong>Mandos</strong> i d’una <strong>testnet</strong> (local), que permeten <strong>automatitzar les proves</strong> en un entorn controlat (<span class="citation" data-cites="elrond2022"></span>, seccions “<em>Mandos tests reference</em>” i “<em>Setup a Local Testnet</em>”). A part de per una qüestió merament de temps (són eines específiques que requereixen un temps d’aprenentatge i no podia abastar-ho tot), per l’objectiu de posar a prova el rediment de la xarxa Elrond he triat realitzar les proves directament a la devnet amb els <em>snippets</em> (m’ha donat certa experiència de camp amb l’eina).</p>
<h3 id="sobre-la-dapp">Sobre la DApp</h3>
<p>S’han comprovat manualment els casos d’ús descrits en la secció <a href="#subsub:casosdus" data-reference-type="ref" data-reference="subsub:casosdus">3.2.1</a>:.</p>
<ol>
<li><p>S’ha afegit liquiditat. En la finestra que apareix en l’opció “Fund” en la llista desplegable apareixen els <em>tokens</em> disponibles al moneder de l’usuari que ha accedit a testDEX (Fig. <a href="#fig:imp-liqpools2" data-reference-type="ref" data-reference="fig:imp-liqpools2">46</a>). Al fons, quan estigui definit, no se li podrà afegir més quantitat d’actius. En qualsevol cas, si es tria el token que defineix el fons ha d’aparèixer la quantitat d’actius que té assignat (Fig. <a href="#fig:imp-liqpools1" data-reference-type="ref" data-reference="fig:imp-liqpools1">45</a>).</p></li>
<li><p>S’han realitzat <em>swaps</em> confirmant que els resultats coincideixen amb l’anàlisi teòric fet a la secció <a href="#subsub:dexamm" data-reference-type="ref" data-reference="subsub:dexamm">3.1.1</a>. En la Fig. <a href="#fig:swaptests" data-reference-type="ref" data-reference="fig:swaptests">[fig:swaptests]</a> es pot comprovar que coincideixen preus calculats, valors transferits i beneficis obtinguts.</p></li>
<li><p>S’han recuperat beneficis i fons. En la Fig. <a href="#fig:imp-fons" data-reference-type="ref" data-reference="fig:imp-fons">[fig:imp-fons]</a> es pot veure l’estat inicial del fons i com queda després de reclamar els beneficis i els fons en si mateixos.</p></li>
<li><p>En totes les finestres de la DApp es mostraran les transaccions relacionades. Filtro les transaccions segons els mètodes del contracte intel·ligent trucats. S’ha comprovat el correcte funcionament.</p></li>
</ol>
<p>Òbviament s’han emprat també els <em>snippets</em> de l’apartat anterior per confirmar els resultats. M’hauria agradat automatitzar el procés de proves amb algun <em>framework</em> de React però no he tingut temps material per formar-me.</p>
<figure>
<img src="imp-liqpools1.png" id="fig:imp-liqpools1" alt="" /><figcaption>Estat del fons ABC-xEGLD.</figcaption>
</figure>
<figure>
<img src="imp-liqpools2.png" id="fig:imp-liqpools2" alt="" /><figcaption><em>Tokens</em> al <em>wallet</em> del client.</figcaption>
</figure>
<figure>
<img src="imp-price1.png" id="fig:imp-price1" alt="" /><figcaption>Preu d’un xEGLD front a UOC.</figcaption>
</figure>
<figure>
<img src="imp-price2.png" id="fig:imp-price2" alt="" /><figcaption><em>Swap</em> d’un xEGLD per UOC.</figcaption>
</figure>
<figure>
<img src="imp-price3.png" id="fig:imp-price3" alt="" /><figcaption>Preu de mil xEGLD front a xEGLD.</figcaption>
</figure>
<figure>
<img src="imp-price4.png" id="fig:imp-price4" alt="" /><figcaption>Beneficis després de fer un <em>swap</em> d’un xEGLD per UOC i seguit de 1000 UOC per xEGLD.</figcaption>
</figure>
<figure>
<img src="imp-fons1.png" id="fig:imp-fons1" alt="" /><figcaption>Abans de reclamar.</figcaption>
</figure>
<figure>
<img src="imp-fons2.png" id="fig:imp-fons2" alt="" /><figcaption>Després de reclamar beneficis.</figcaption>
</figure>
<figure>
<img src="imp-fons3.png" id="fig:imp-fons3" alt="" /><figcaption>Després de reclamar el fons.</figcaption>
</figure>
<h3 id="sobre-el-rendiment-de-la-devnet-delrond">Sobre el rendiment de la <em>devnet</em> d’Elrond</h3>
<p>Un dels objectius del present treball és definir proves per comprovar les característiques de la xarxa Elrond. En la secció <a href="#sub:xarxes" data-reference-type="ref" data-reference="sub:xarxes">2.9</a> s’han comentat les característiques bàsiques de la <em>devnet</em>, en la <a href="#subsub:arq" data-reference-type="ref" data-reference="subsub:arq">3.2.3</a> l’arquitectura de testDEX i en la <a href="#imp:aspectes" data-reference-type="ref" data-reference="imp:aspectes">3.3.2</a> les diferents formes en què ens hem comunicat a la <em>blockchain</em>. Tenint en compte tot això, amb la intenció de mesurar el temps que triga a realitzar les peticions s’ha realitzat un <em>script</em> en Python, que com he dit es troba en el repositori TFM_stats.</p>
<p>Les transaccions per unitat de temps poden ser un bon indicador per valorar el rendiment de la devnet. Com s’ha vist, si el moneder que envia la transacció es troba al mateix s<em>hard</em> que el contracte intel·ligent la transacció serà més ràpida que si es troba en un altre <em>shard</em>. Des de Python he trobat una solució per enviar transaccions en bloc, però per recuperar-les no he trobat forma de disparar automàticament una funció que tracti la resposta. Ho he implementat amb un bucle que demana les dades de les transaccions segons el seu <em>hash</em> a l’API d’Elrond fins que totes tenen l’estat a “<em>success</em>”. Això s’ha de tenir en compte perquè els resultats que es mostren, per aquest motiu, tenen un retard afegit.</p>
<p>El que fa el <em>script</em> és enviar un conjunt de transaccions que trucaran el mètode del contracte intel·ligent “addLiquidityEgld” passant-li com a paràmetre “ABC-109739” (un <em>token</em> creat per mi). A més cada transacció transportarà un valor de 0,01 xEGLD. Amb això el que estem fent és fundar amb xEGLD el fons ABC-xEGLD. En la Fig. <a href="#fig:send5trans" data-reference-type="ref" data-reference="fig:send5trans">54</a> es veu un exemple d’execució per a un total de 5 transaccions<a href="#fn62" class="footnote-ref" id="fnref62" role="doc-noteref"><sup>62</sup></a> (5 transaccions executades en 2,896 segons).</p>
<p>Provant d’enviar un nombre més considerable de transaccions, m’he adonat que a partir de les 2500 transaccions el <em>script</em> falla. Però per a 2000 ha obtingut que s’han realitzat en 7 minuts i 7 segons<a href="#fn63" class="footnote-ref" id="fnref63" role="doc-noteref"><sup>63</sup></a>. S’ha de remarcar que això implica que s’han enviat 20 xEGLD al fons remartits entre 2000 transaccions (0.01 xEGLD/transacció). En la Fig. <a href="#fig:send2000trans1" data-reference-type="ref" data-reference="fig:send2000trans1">55</a> es pot veure una captura del resultat.</p>
<p>Una altra prova obligada és fer les transaccions amb un moneder que es trobi en un altre <em>shard</em>. Com que no serà el propietari del contracte intel·ligent, aquest respondrà que no pot fundar el fons. Això implica que la màquina virtual no executarà pràcticament codi. Per aquest motiu, he tornat a llançar el test amb un <em>wallet</em> que no és propietari del contracte intel·ligent, però que es troba al mateix <em>shard</em> (després ho provaré també amb un fragment diferent). En aquest darrer cas, per a 5 transaccions (Fig. <a href="#fig:send5transnotowner" data-reference-type="ref" data-reference="fig:send5transnotowner">56</a>) ha trigat 1 segon (1852 ms) i per a 2000 ha tardat 7 minuts i 3 segons (Fig. <a href="#fig:send2000transnotowner" data-reference-type="ref" data-reference="fig:send2000transnotowner">57</a>).<a href="#fn64" class="footnote-ref" id="fnref64" role="doc-noteref"><sup>64</sup></a></p>
<p>Dit tot això, la prova ja des d’un compte que no és propietari del contracte i que no es troba al mateix <em>shard</em> ha trigat 31 segons per a 5 transaccions (Fig. <a href="#fig:send5transnotownerothershards" data-reference-type="ref" data-reference="fig:send5transnotownerothershards">58</a>) i per a 2000 transaccions 7 minuts i 31 segons (Fig. <a href="#fig:send2000transnotownerothershards" data-reference-type="ref" data-reference="fig:send2000transnotownerothershards">59</a>).<a href="#fn65" class="footnote-ref" id="fnref65" role="doc-noteref"><sup>65</sup></a></p>
<p>Totalitzant aquestes dades en una taula:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Núm. trans.</strong></th>
<th style="text-align: left;"><em><strong>Shard</strong></em></th>
<th style="text-align: left;"><em><strong>Owner</strong></em></th>
<th style="text-align: left;"><strong>Figura</strong></th>
<th style="text-align: left;"><strong>Temps (ms)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">sí</td>
<td style="text-align: left;"><a href="#fig:send5trans" data-reference-type="ref" data-reference="fig:send5trans">54</a></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">sí</td>
<td style="text-align: left;"><a href="#fig:send2000trans1" data-reference-type="ref" data-reference="fig:send2000trans1">55</a></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">no</td>
<td style="text-align: left;"><a href="#fig:send5transnotowner" data-reference-type="ref" data-reference="fig:send5transnotowner">56</a></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">no</td>
<td style="text-align: left;"><a href="#fig:send2000transnotowner" data-reference-type="ref" data-reference="fig:send2000transnotowner">57</a></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">no</td>
<td style="text-align: left;"><a href="#fig:send5transnotownerothershards" data-reference-type="ref" data-reference="fig:send5transnotownerothershards">58</a></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">no</td>
<td style="text-align: left;"><a href="#fig:send2000transnotownerothershards" data-reference-type="ref" data-reference="fig:send2000transnotownerothershards">59</a></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>És molt petita la mostra per extreure conclusions fermes, però veiem que quan s’augmenta el nombre de transaccions enviades el temps que triga en els diferents casos convergeix. Amb 2000 transaccions el cas d’un remitent que no és propietari del <em>smart contract</em> i que es troba en un altre <em>shard</em> és només entorn d’un 5% més lent. Tot això fa pensar que <strong>l’arquitectura en <em>shards</em> és eficient</strong>. També s’ha de destacar, com s’ha dit en la secció <a href="#sub:xarxes" data-reference-type="ref" data-reference="sub:xarxes">2.9</a>, que la devnet té només 300 nodes validadors, enfront de la testnet i la mainnet que en tenen 3000. Per sortir de dubtes, he desplegat el contracte intel·ligent a la testnet amb:</p>
<pre><code>[
    basicstyle=\footnotesize,
]
erdpy contract deploy --pem=&quot;~/wallet/wallet3.pem&quot; \
  --recall-nonce --gas-limit=100000000 --project=. \
  --proxy=&quot;https://testnet-gateway.elrond.com&quot; \
  --chain=&quot;T&quot; --arguments 0x05 --send</code></pre>
<p>I he tornat a fer la prova amb 2000 transaccions<a href="#fn66" class="footnote-ref" id="fnref66" role="doc-noteref"><sup>66</sup></a>. Sorprenetment, s’han executat en 8 minuts i 56 segons (536538 ms). Es pot veure una captura en la Fig. <a href="#fig:sendtesnet" data-reference-type="ref" data-reference="fig:sendtesnet">60</a>.</p>
<figure>
<img src="send5trans.png" id="fig:send5trans" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 5 transaccions.</figcaption>
</figure>
<figure>
<img src="send2000trans1.png" id="fig:send2000trans1" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 2000 transaccions (es mostren només els darrer <em>hashes</em>).</figcaption>
</figure>
<figure>
<img src="send5transnotowner.png" id="fig:send5transnotowner" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 5 transaccions amb un remitent que no és el propietari del <em>smart contract</em> però que es troba al mateix <em>shard</em>.</figcaption>
</figure>
<figure>
<img src="send2000transnotowner.png" id="fig:send2000transnotowner" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 2000 transaccions amb un remitent que no és el propietari del <em>smart contract</em> però que es troba al mateix <em>shard</em>.</figcaption>
</figure>
<figure>
<img src="send5transnotownerothershards.png" id="fig:send5transnotownerothershards" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 5 transaccions amb un remitent que no és el propietari del <em>smart contract</em> i que a més no es troba al mateix <em>shard</em>.</figcaption>
</figure>
<figure>
<img src="send2000transnotownerothershards.png" id="fig:send2000transnotownerothershards" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 2000 transaccions amb un remitent que no és el propietari del <em>smart contract</em> i que a més no es troba al mateix <em>shard</em>.</figcaption>
</figure>
<figure>
<img src="sendtestnet.png" id="fig:sendtesnet" style="width:99.0%" alt="" /><figcaption>Resultat del <em>script</em> de Python executat per a 2000 transaccions em a testnet.</figcaption>
</figure>
<h1 id="sec:con">Conclusions</h1>
<p>Déu-n’hi-do per arribar fins aquí. Era allunyat de la programació de fa més de deu anys i ha estat un camí pedregós. Tampoc tenia gaire idea de <em>blockchain</em> (no he cursat l’assignatura). En qualsevol cas, que hagi pogut finalitzar el present treball és bona mostra de què <strong>l’entorn d’Elrond és força amigable per al programador</strong> (punt important per a la seva adopció). Aquesta companyia ha avançat molt ràpid i, tot i que han desenvolupat molts de continguts per a aprendre la seva tecnologia, podrien estar millor (sobretot he trobat a faltar exemples amb codi font executable del que s’explica a <span class="citation" data-cites="elrond2022"></span>). Com que és un projecte relativament recent, no trobes gaire codi a Github, no hi ha cap curs a Udemy o altres plataformes (Ethereum té una gran comunitat de desenvolupadors i molt de material disponible). Per contra, simplement provant testDEX, veus que <strong>les transaccions van força més ràpid que amb Ethereum</strong>. Diferents fonts –com <span class="citation" data-cites="mincub2019-2"></span> o <span class="citation" data-cites="everstake2020"></span>)– parlem de més de 10000 TPS. Imagino que els meus resultats són més discrets en fer proves en una xarxa configurada amb només 3 <em>shards</em><a href="#fn67" class="footnote-ref" id="fnref67" role="doc-noteref"><sup>67</sup></a>, per la penalització en temps induïda per la meva implementació i per les eines emprades (que possiblement duen incorporades limitacions per a no saturar la xarxa).</p>
<p>Penso que el present treball revisa la tecnologia d’Elrond amb un mínim de rigor acadèmic, que s’ha realitzat un exemple pràctic (molt millorable per la meva inexperiència com a programador) i que s’ha comprovat el funcionament de la xarxa Elrond d’una forma molt bàsica. Per altra banda, aquest treball possiblement sigui un dels primers en llengua catalana emprant aquesta tecnologia. En la secció <a href="#sub:objectius" data-reference-type="ref" data-reference="sub:objectius">1.2</a> no he citat el meu objectiu personal, que era bàsicament aprendre. Penso que això sí que s’ha assolit al 150%.</p>
<p>Com a <strong>crítica personal</strong>, la meva falta de coneixements i d’experiència en el desenvolupament de programari ha fet que em desviï uns quants dies en la planificació prevista. Inicialment, en el disseny vaig plasmar que volia fer també un gràfic sobre l’evolució dels preus però vaig haver de retallar el projecte un poc per falta de temps (he de dir que n’he hagut de dedicar més temps del que esperava). També <em>script</em> en Python es podria haver parametritzat i haver fet més genèric (sé que són unes poques hores de feina però no he pogut arribar-hi). O ha faltat emprar alguna bona metodologia per fer proves mentre s’implementava la DApp. En definitiva, em quedo amb un regust agredolç.</p>
<p>Com a <strong>línies de treball futures</strong>, parlant a títol personal, ara tinc clara una línia de formació que he de seguir per suplir les meves carències. El meu perfil és més de sistemes i de sistemes gestors de bases de dades, però m’està fascinant el món de les cadenes de blocs. Vull formar-me en React i Rust i refer tot el codi (o tal vegada fer-ne un de nou relacionat amb NFT). Parlant a nivell de potencials futurs treballs de final de grau o de màster, la part d’estudi del rendiment a nivell de TPS és un bon filó per explotar (tot i que penso que sense la colaboració de l’equip d’Elrond en algunes coses pot ser complicat). Tampoc no s’ha fet cap estudi de les despeses que duen associades les transaccions (punt on Elrond és també superior a Ethereum <span class="citation" data-cites="paradigm2019"></span> <span class="citation" data-cites="everstake2020"></span>). Per altra banda, penso que la meva idea original de fer un bon material didàctic amb exemples per aprendre a desenvolupar en la tecnologia Elrond crec que seria força interessant per la falta de material en general. Finalment, amb els problemes exposats per a la constant <span class="math inline"><em>k</em></span> es podria desenvolupar més aquest punt seguint les fonts bibliogràfiques disponibles (<span class="citation" data-cites="zhang2018"></span>).</p>
<p>La meva conclusió final, dins de la meva humil opinió de neòfit en el món del <em>blockchain</em>, és que tenint en compte l’eficiència de la xarxa, la limitació en el cost de les transaccions i el maquinari genèric que es necessita per poder posar en producció un node de la xarxa<a href="#fn68" class="footnote-ref" id="fnref68" role="doc-noteref"><sup>68</sup></a>, la tecnologia d’<strong>Elrond és encara infravalorada</strong>.</p>
<h1 id="sec:glo">Glossari</h1>
<ul>
<li><p><strong>AMM (<em>Automated Market Makers</em>)</strong>: Protocol que determina automàticament els preus d’un parell d’actius que conformen un fons de liquiditat.</p></li>
<li><p><strong><em>Blockchain</em> (cadena de blocs)</strong>: Base de dades distribuïda de comptabilitat que es comparteix entre els nodes d’una xarxa informàtica sense una autoritat central que els gestioni.</p></li>
<li><p><strong>DApp (<em>Decentralized Application</em>)</strong>: És una aplicació que funciona sense la necessitat de servidors centrals (gràcies a la tecnologia <em>blockchain</em>).</p></li>
<li><p><strong>DEX (<em>Decentralized EXchange</em>)</strong>: Mercat d’igual a igual on les transaccions es produeixen directament entre els usuaris sense la intervenció de cap autoritat de control central.</p></li>
<li><p><strong>PoW (<em>Proof of Work</em>)</strong>: És un protocol de consens en sistemes descentralitzats que per verificar els blocs i les transaccions requereix els membres de la xarxa que resolguin un problema matemàtic arbitrari que duu associat un càlcul considerable, evitant així que ningú utilitzi de forma il·lícta el sistema.</p></li>
<li><p><strong>PoS (<em>Proof of Stake</em>)</strong>: Alternativa a PoW que redueix la potència de càlcul associada per verificar els blocs i les transaccions gràcies a un algoritme de consens amb la participació de nodes validadors que han d’aportar criptoactius com a fiança (<em>stake</em>).</p></li>
<li><p><strong><em>Smart contract</em></strong>: Contracte emmagatzemat en una <em>blockchain</em> que permet l’execució automàtica de certs termes acordats gràcies a un programa informàtic.</p></li>
<li><p><strong><em>Token</em></strong>: Unitat de valor fonamentada en la criptografia i <em>blockchain</em>.</p></li>
</ul>
<h1 id="sec:bib">Bibliografia</h1>
<h1 id="sec:ann">Annexos</h1>
<h2 id="sub:manual">Breu manual d’usuari de testDEX</h2>
<h2 id="introducció-1">Introducció</h2>
<p>L’aplicació bàsicament té dos perfils d’usuari:</p>
<ul>
<li><p>Propietari del contracte intel·ligent: Podrà accedir a totes les opcions del menú.</p></li>
<li><p>Resta d’usuaris de la xarxa Elrond: Podran accedir només a l’opció “Trading”.</p></li>
</ul>
<h2 id="opció-fund">Opció “Fund”</h2>
<p>Permet el propietari del contracte intel·ligent fundar un <em>liquidity pool</em>. En la llista desplegable “Select token” li apareixaran els diferents tokens ESDT disponibles en la seva cartera. Es triarà un d’aquest tokens (“Select token”) i se li afegirà una quantitat determinada del mateix (“Amount token”) i una altra quantitat de xEGLD (“Amount EGLD”). Una vegada fundat el fons no se li podem afegir més actius (a no ser que es reclami i es torni a fundar). Quan es seleccioni un token es mostraran la quantitat d’actius pels que està format (camps “Already funded”).</p>
<figure>
<img src="manualfund.png" id="fig:manualfund" style="width:60.0%" alt="" /><figcaption>Opció “Fund” a testDEX.</figcaption>
</figure>
<h2 id="opció-claim">Opció “Claim”</h2>
<p>Permet el propietari del contracte intel·ligent recuperar els fons de liquiditat o bé els seus beneficis. Basta triar un <em>token</em> de la llista desplegable (“Select pair”) i prémer el botó “Claim earnings” o bé “Claim pool” (es mostraran només els <em>pools</em> disponibles en el <em>smart contract</em>). S’ha de destacar que quan es recuperin els beneficis d’un <strong>pool</strong> es recuperarà el xEGLD de tots (no només del parell definit pel <strong>token</strong> seleccionat). Quan es seleccioni un token es mostraran la quantitat d’actius pels que està format el fons i el beneficis disponibles (camps “Pool available” i camp “Earnings available”).</p>
<figure>
<img src="manualclaim.png" id="fig:manualclaim" style="width:60.0%" alt="" /><figcaption>Opció “Claim” a testDEX.</figcaption>
</figure>
<h2 id="opció-trade">Opció “Trade”</h2>
<p>En la llista desplegable es podran seleccionar els parells disponibles en el contracte intel·ligent per fer <em>trading</em>. Quan es triï un parell es mostran les quantitats dels actius disponibles en el pool i en el moneder de l’usuari (camps “Pool (amount available)” i “Your wallet (amount available)”). Quan s’introdueixi una quantitat (“Amount”), es calcularà automàticament tant el preu de compra com el de venda (camps “Buy” i “Sell”).</p>
<p>Un darrer comentari és que no s’ha limitat l’entrada de nombres que l’usuari pot introduir al quadre de text amb la quantitat. Així es pot provar el comportament del contracte intel·ligent en casos extrems.</p>
<figure>
<img src="manualtrade.png" id="fig:manualtrade" style="width:60.0%" alt="" /><figcaption>Opció “Claim” a testDEX.</figcaption>
</figure>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Per exemple el “<em>b-money</em>” de W. Dai (1998) <span class="citation" data-cites="dai1998"></span>, el “<em>Reusable Proofs of Work</em>” de H. Finney (2005) <span class="citation" data-cites="finney2005"></span> o el “<em>Bit gold</em>” de N. Szabo (2008) <span class="citation" data-cites="szabo2008"></span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>No és l’objectiu del present treball explicar els sistemes de <em>blockchain</em>, però una gran exposició gràfica la realitza A. Brownworth <span class="citation" data-cites="brownworth1"></span><span class="citation" data-cites="brownworth2"></span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>S’han fet proves a la <em>testnet</em> amb pics de més de 260k TPS <span class="citation" data-cites="elrond2022"></span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://maiar.com/">https://maiar.com/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://wallet.elrond.com/">https://wallet.elrond.com/</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Per aconseguir el <em>plugin</em> per al teu navegador: <a href="https://getmaiar.com/defi">https://getmaiar.com/defi</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="https://maiar.exchange/">https://maiar.exchange/</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="https://www.trailofbits.com/">https://www.trailofbits.com/</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p><a href="https://runtimeverification.com/">https://runtimeverification.com/</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Existeix el <em>plugin</em> “Elrond IDE”: <a href="https://marketplace.visualstudio.com/items?itemName=Elrond.vscode-elrond-ide">https://marketplace.visualstudio.com/items?itemName=Elrond.vscode-elrond-ide</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>En el present treball empraré indistintament “<em>blockchain</em>” i “cadena de blocs” (traducció del terme proposada pel Termcat).<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>El Termcat encara no ha traduït el terme, és una traducció pròpia que penso que fa entendre el concepte.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>No hi ha entrada al Termcat pel terme “shard”, jo l’he traduït per “fragment” (empraré ambdues paraules indistintament en el present treball).<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p><a href="https://webassembly.org/">https://webassembly.org/</a><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>En el present treball empraré els termes “cartera” o “moneder” indistintament per referir-me al concepte de “<em>wallet</em>”.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>No es diu explícitament en la bibliografia però investigant pels grups de Telegram d’Elrond (concretament en <a href="https://t.me/ElrondValidators">https://t.me/ElrondValidators</a>) vaig descobrir que el concepte de “<em>fisherman</em>” encara no està implementat.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>El SPoS d’Elrond es basa en la premissa que un actor malèvol només té el temps que dura una ronda per adaptar-se i intentar influir en el bloc que es proposarà.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>Per aclarir del tot aquest punt, en la bibliografia emprada, líder de consens, líder de validació i proposador de bloc (<em>block proposer</em>) fan referència al mateix concepte.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Aquest concepte es podria traduir al català com “fragmentació de la xarxa” però he preferit deixar el terme anglès. El mateix passa amb <em>transaction sharding</em> i <em>state sharding</em>, que es podrien traduir respectivament per “fragmentació de les transaccions” i “fragmentació de l’estat”.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>En <span class="citation" data-cites="elrond2019"></span> es pot trobar una funció en pseudocodi amb la que calcular el nombre òptim de <em>shards</em>.<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>Aquest paràgraf és un resum molt breu. Per referències més detallades consultar <span class="citation" data-cites="elrond2019"></span>.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>“Donar fe” o “autenticar” són les traduccions al català que he trobat més adients pel verb anglès “to notarize”. El verb “notarizar” existeix en espanyol, però no existeix “notaritzar” en català. En qualsevol cas, empraré aquest darrer terme en algunes ocasions entre cometes per no generar confusions.<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p><a href="https://webassembly.org/">https://webassembly.org/</a><a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24" role="doc-endnote"><p><a href="https://github.com/ElrondNetwork/elrond-wasm-rs">https://github.com/ElrondNetwork/elrond-wasm-rs</a><a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25" role="doc-endnote"><p><a href="https://marketplace.visualstudio.com/items?itemName=Elrond.vscode-elrond-ide">https://marketplace.visualstudio.com/items?itemName=Elrond.vscode-elrond-ide</a><a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26" role="doc-endnote"><p><a href="https://wasmer.io/">https://wasmer.io/</a><a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27" role="doc-endnote"><p>Realitzada per Wasmer Inc. Aquesta empresa també ha creat un gestor de paquets que permet els desenvolupadors compartir mòduls empaquetats de codi Wasm.<a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28" role="doc-endnote"><p>En el grup de Telegram “<em>Elrond Validators Announcements</em>” (<a href="https://t.me/ElrondValidatorsAnn">https://t.me/ElrondValidatorsAnn</a>) es va anunciar que es faria una ronda de gènisi per la <em>devnet</em> (reinici) per a dia 29 de març de 2022.<a href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29" role="doc-endnote"><p>Programari disponible a: <a href="https://github.com/ElrondNetwork/elrond-go">https://github.com/ElrondNetwork/elrond-go</a>.<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30" role="doc-endnote"><p>Es recomana Ubuntu 20.04.<a href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31" role="doc-endnote"><p>Traducció del Termcat del terme “<em>howto</em>”.<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32" role="doc-endnote"><p>Aquesta secció torna a ser una síntesi de l’apartat “<em>Validators</em>” de <span class="citation" data-cites="elrond2022"></span>.<a href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33" role="doc-endnote"><p>Per a la <em>devnet</em> i la <em>testnet</em> es disposa d’una opció “<em>Faucet</em>” per obtenir xEGLD (que no té cap cost en moneda <em>fiat</em> i et permetrà poder relalitzar transaccions).<a href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34" role="doc-endnote"><p>Ha de tenir almenys nou caràcters, una lletra majúscula, un símbol i un nombre.<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35" role="doc-endnote"><p><a href="https://chrome.google.com/webstore/detail/maiar-defi-wallet/">https://chrome.google.com/webstore/detail/maiar-defi-wallet/</a><a href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn36" role="doc-endnote"><p><a href="https://metamask.io/">https://metamask.io/</a><a href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn37" role="doc-endnote"><p><a href="https://maiar.com/">https://maiar.com/</a><a href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn38" role="doc-endnote"><p>En català balear fem ús del verb “cridar” en lloc del verb “trucar”. Així diem per exemple “cridar per telèfon” o “cridar el mètode d’un objecte”.<a href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn39" role="doc-endnote"><p><a href="https://maiar.exchange/">https://maiar.exchange/</a><a href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40" role="doc-endnote"><p>No m’he atrevit a traduir aquest terme, però un mot que m’agrada del català és “conrear”.<a href="#fnref40" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn41" role="doc-endnote"><p><a href="https://www.elastic.co/">https://www.elastic.co/</a><a href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn42" role="doc-endnote"><p>En el present treball empraré indistintament els termes EGLD i xEGLD. En qualsevol cas, ha de quedar clar que EGLD es fa servir en la mainet (té un cost econòmic) i xEGLD es fa servir en la devnet/testnet.<a href="#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43" role="doc-endnote"><p><a href="https://uniswap.org/">https://uniswap.org/</a><a href="#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn44" role="doc-endnote"><p><a href="https://pancakeswap.finance/">https://pancakeswap.finance/</a><a href="#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn45" role="doc-endnote"><p>He imitat els diagrames explicatius de la documentació d’Elrond <span class="citation" data-cites="elrond2022"></span> i per això no he fet servir diagrames de casos d’ús d’UML. El contingut de les figures es troba en anglès ja que és l’idioma que he emprat en el codi font.<a href="#fnref45" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn46" role="doc-endnote"><p>Quan s’implementin les propietats i mètodes públics en el lleguatge Rust s’anotaran amb #[endpoint] o #[view].<a href="#fnref46" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn47" role="doc-endnote"><p>Estructura de dades que representa un nombre enter molt gran sense signe.<a href="#fnref47" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn48" role="doc-endnote"><p>Sencer sense signe representat amb 32 bits.<a href="#fnref48" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn49" role="doc-endnote"><p>Idea extreta dels exercicis que desenvolupen el material didàctic descrit a <span class="citation" data-cites="delarosa"></span>.<a href="#fnref49" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn50" role="doc-endnote"><p><a href="https://github.com/sergiogrubio/TFM_latex">https://github.com/sergiogrubio/TFM_latex</a><a href="#fnref50" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn51" role="doc-endnote"><p><a href="https://github.com/sergiogrubio/TFM_smart_contract">https://github.com/sergiogrubio/TFM_smart_contract</a><a href="#fnref51" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn52" role="doc-endnote"><p><a href="https://github.com/sergiogrubio/TFM_DApp">https://github.com/sergiogrubio/TFM_DApp</a><a href="#fnref52" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn53" role="doc-endnote"><p><a href="https://github.com/ElrondNetwork/DApp-template">https://github.com/ElrondNetwork/DApp-template</a><a href="#fnref53" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn54" role="doc-endnote"><p><a href="https://github.com/sergiogrubio/TFM_stats">https://github.com/sergiogrubio/TFM_stats</a><a href="#fnref54" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn55" role="doc-endnote"><p><a href="https://devnet-api.elrond.com/">https://devnet-api.elrond.com/</a><a href="#fnref55" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn56" role="doc-endnote"><p>També es pot fer amb els <em>snippets</em>, que seran explicats en la secció <a href="#subsub:sc" data-reference-type="ref" data-reference="subsub:sc">3.5.1</a>.<a href="#fnref56" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn57" role="doc-endnote"><p><a href="https://www.ovhcloud.com/">https://www.ovhcloud.com/</a><a href="#fnref57" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn58" role="doc-endnote"><p>Com configurar l’entorn per desenvolupar en la xarxa Elrond es pot consultar en <span class="citation" data-cites="elrondnet2020"></span> i <span class="citation" data-cites="ton2021"></span>.<a href="#fnref58" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn59" role="doc-endnote"><p>S’ha de destacar que en el resultat del <em>snippet</em> apareixarà un enllaç cap a l’explorador de transaccions de la xarxa d’Elrond on es podrà comprovar si ha funcionat correctament o ha aparegut algun error (òbviament, es provaran situacions que haurien de generar error i en aquest cas el comportament anòmal és que funcioni correctament).<a href="#fnref59" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn60" role="doc-endnote"><p><span id="note1" label="note1">[note1]</span>Hi ha tres <em>snippets</em> per coincidir amb la implementació que s’ha exposat en la secció <a href="#subsub:sc" data-reference-type="ref" data-reference="subsub:sc">3.5.1</a>.<a href="#fnref60" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn61" role="doc-endnote"><p><a href="#note1" data-reference-type="ref" data-reference="note1">[note1]</a><a href="#fnref61" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn62" role="doc-endnote"><p>En el codi font han d’estar definits <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 5</span> i <span class="math inline">${PEM={'\texttildelow/wallet/wallet3.pem'}}$</span>.<a href="#fnref62" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn63" role="doc-endnote"><p>En el codi font han d’estar definits <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 2000</span> i <span class="math inline">${PEM={'\texttildelow/wallet/wallet3.pem'}}$</span>.<a href="#fnref63" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn64" role="doc-endnote"><p>En el codi font han d’estar definits <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 5</span> o <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 2000</span> i <span class="math inline">${PEM={'\texttildelow/wallet/wallet1.pem'}}$</span>.<a href="#fnref64" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn65" role="doc-endnote"><p>En el codi font han d’estar definits <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 5</span> o <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 2000</span> i <span class="math inline">${PEM={'\texttildelow/wallet/wallet2.pem'}}$</span>.<a href="#fnref65" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn66" role="doc-endnote"><p>En el codi font han d’estar ha d’estar definit <span class="math inline"><em>N</em><em>U</em><em>M</em>_<em>T</em><em>R</em><em>A</em><em>N</em><em>S</em> = 2000</span>, <span class="math inline">${PEM={'\texttildelow/wallet/wallet3.pem'}}$</span>, <span class="math inline"><em>C</em><em>H</em><em>A</em><em>I</em><em>N</em>_<em>I</em><em>D</em> = ′<em>T</em>′</span> i <span class="math inline"><em>C</em><em>O</em><em>N</em><em>T</em><em>R</em><em>A</em><em>C</em><em>T</em>_<em>A</em><em>D</em><em>D</em><em>R</em><em>E</em><em>S</em><em>S</em> = ′<em>e</em><em>r</em><em>d</em>1<em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>q</em><em>p</em><em>g</em><em>q</em><em>s</em>3<em>m</em><em>n</em><em>l</em>4<em>q</em><em>n</em><em>q</em><em>r</em><em>e</em><em>n</em><em>z</em><em>m</em><em>a</em><em>e</em><em>z</em><em>f</em>72<em>v</em><em>z</em><em>e</em><em>g</em>5<em>s</em><em>n</em><em>p</em><em>e</em>9<em>p</em>0<em>s</em><em>n</em>2<em>q</em><em>v</em><em>e</em><em>u</em><em>c</em><em>s</em>5′</span>.<a href="#fnref66" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn67" role="doc-endnote"><p>“<em>Testnet exceeded 12k TPS with only 5 shards and 65k with 20 shards</em> [...]” (<span class="citation" data-cites="paradigm2019"></span>).<a href="#fnref67" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn68" role="doc-endnote"><p>Aquest punt pot ser controvertit per la quantitat d’EGLD que s’ha de mantenir en <em>staking</em> (en l’hipotètic escenari que pugi molt de preu).<a href="#fnref68" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
